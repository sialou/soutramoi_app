{"ast":null,"code":"import _asyncToGenerator from \"/home/digifemmes-22lab149/Bureau/soutramoi_app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nconst NAMESPACE = 'ionicpwaelements';\nlet queueCongestion = 0;\nlet queuePending = false;\nlet scopeId;\nlet hostTagName;\nlet isSvgMode = false;\nconst win = typeof window !== 'undefined' ? window : {};\nconst CSS = win.CSS;\nconst doc = win.document || {\n  head: {}\n};\nconst plt = {\n  $flags$: 0,\n  $resourcesUrl$: '',\n  jmp: h => h(),\n  raf: h => requestAnimationFrame(h),\n  ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),\n  rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts)\n};\nconst supportsShadowDom = /*@__PURE__*/(() => (doc.head.attachShadow + '').indexOf('[native') > -1)();\nconst promiseResolve = v => Promise.resolve(v);\nconst supportsConstructibleStylesheets = /*@__PURE__*/(() => {\n  try {\n    new CSSStyleSheet();\n    return true;\n  } catch (e) {}\n  return false;\n})();\nconst Context = {};\nconst hostRefs = new WeakMap();\nconst getHostRef = ref => hostRefs.get(ref);\nconst registerInstance = (lazyInstance, hostRef) => hostRefs.set(hostRef.$lazyInstance$ = lazyInstance, hostRef);\nconst registerHost = elm => {\n  const hostRef = {\n    $flags$: 0,\n    $hostElement$: elm,\n    $instanceValues$: new Map()\n  };\n  {\n    hostRef.$onInstancePromise$ = new Promise(r => hostRef.$onInstanceResolve$ = r);\n  }\n  {\n    hostRef.$onReadyPromise$ = new Promise(r => hostRef.$onReadyResolve$ = r);\n    elm['s-p'] = [];\n    elm['s-rc'] = [];\n  }\n  return hostRefs.set(elm, hostRef);\n};\nconst isMemberInElement = (elm, memberName) => memberName in elm;\nconst consoleError = e => console.error(e);\nconst moduleCache = /*@__PURE__*/new Map();\nconst loadModule = (cmpMeta, hostRef, hmrVersionId) => {\n  // loadModuleImport\n  const exportName = cmpMeta.$tagName$.replace(/-/g, '_');\n  const bundleId = cmpMeta.$lazyBundleIds$;\n  const module = moduleCache.get(bundleId);\n  if (module) {\n    return module[exportName];\n  }\n  return import( /* webpackInclude: /\\.entry\\.js$/ */\n  /* webpackExclude: /\\.system\\.entry\\.js$/ */\n  /* webpackMode: \"lazy\" */\n  `./${bundleId}.entry.js${''}`).then(importedModule => {\n    {\n      moduleCache.set(bundleId, importedModule);\n    }\n    return importedModule[exportName];\n  }, consoleError);\n};\nconst styles = new Map();\nconst queueDomReads = [];\nconst queueDomWrites = [];\nconst queueDomWritesLow = [];\nconst queueTask = (queue, write) => cb => {\n  queue.push(cb);\n  if (!queuePending) {\n    queuePending = true;\n    if (write && plt.$flags$ & 4 /* queueSync */) {\n      nextTick(flush);\n    } else {\n      plt.raf(flush);\n    }\n  }\n};\nconst consume = queue => {\n  for (let i = 0; i < queue.length; i++) {\n    try {\n      queue[i](performance.now());\n    } catch (e) {\n      consoleError(e);\n    }\n  }\n  queue.length = 0;\n};\nconst consumeTimeout = (queue, timeout) => {\n  let i = 0;\n  let ts = 0;\n  while (i < queue.length && (ts = performance.now()) < timeout) {\n    try {\n      queue[i++](ts);\n    } catch (e) {\n      consoleError(e);\n    }\n  }\n  if (i === queue.length) {\n    queue.length = 0;\n  } else if (i !== 0) {\n    queue.splice(0, i);\n  }\n};\nconst flush = () => {\n  queueCongestion++;\n  // always force a bunch of medium callbacks to run, but still have\n  // a throttle on how many can run in a certain time\n  // DOM READS!!!\n  consume(queueDomReads);\n  const timeout = (plt.$flags$ & 6 /* queueMask */) === 2 /* appLoaded */ ? performance.now() + 10 * Math.ceil(queueCongestion * (1.0 / 22.0)) : Infinity;\n  // DOM WRITES!!!\n  consumeTimeout(queueDomWrites, timeout);\n  consumeTimeout(queueDomWritesLow, timeout);\n  if (queueDomWrites.length > 0) {\n    queueDomWritesLow.push(...queueDomWrites);\n    queueDomWrites.length = 0;\n  }\n  if (queuePending = queueDomReads.length + queueDomWrites.length + queueDomWritesLow.length > 0) {\n    // still more to do yet, but we've run out of time\n    // let's let this thing cool off and try again in the next tick\n    plt.raf(flush);\n  } else {\n    queueCongestion = 0;\n  }\n};\nconst nextTick = /*@__PURE__*/cb => promiseResolve().then(cb);\nconst readTask = /*@__PURE__*/queueTask(queueDomReads, false);\nconst writeTask = /*@__PURE__*/queueTask(queueDomWrites, true);\n/**\n * Default style mode id\n */\n/**\n * Reusable empty obj/array\n * Don't add values to these!!\n */\nconst EMPTY_OBJ = {};\n/**\n * Namespaces\n */\nconst SVG_NS = 'http://www.w3.org/2000/svg';\nconst HTML_NS = 'http://www.w3.org/1999/xhtml';\nconst isDef = v => v != null;\nconst isComplexType = o => {\n  // https://jsperf.com/typeof-fn-object/5\n  o = typeof o;\n  return o === 'object' || o === 'function';\n};\nconst getDynamicImportFunction = namespace => `__sc_import_${namespace.replace(/\\s|-/g, '_')}`;\nconst patchEsm = () => {\n  // @ts-ignore\n  if (!(CSS && CSS.supports && CSS.supports('color', 'var(--c)'))) {\n    // @ts-ignore\n    return import( /* webpackChunkName: \"stencil-polyfills-css-shim\" */'./css-shim-8775d9ad-556f0cc2.js').then(() => {\n      if (plt.$cssShim$ = win.__cssshim) {\n        return plt.$cssShim$.i();\n      } else {\n        // for better minification\n        return 0;\n      }\n    });\n  }\n  return promiseResolve();\n};\nconst patchBrowser = () => {\n  {\n    // shim css vars\n    plt.$cssShim$ = win.__cssshim;\n  }\n  // @ts-ignore\n  const scriptElm = Array.from(doc.querySelectorAll('script')).find(s => new RegExp(`\\/${NAMESPACE}(\\\\.esm)?\\\\.js($|\\\\?|#)`).test(s.src) || s.getAttribute('data-stencil-namespace') === NAMESPACE);\n  const opts = {};\n  if ('onbeforeload' in scriptElm && !history.scrollRestoration /* IS_ESM_BUILD */) {\n    // Safari < v11 support: This IF is true if it's Safari below v11.\n    // This fn cannot use async/await since Safari didn't support it until v11,\n    // however, Safari 10 did support modules. Safari 10 also didn't support \"nomodule\",\n    // so both the ESM file and nomodule file would get downloaded. Only Safari\n    // has 'onbeforeload' in the script, and \"history.scrollRestoration\" was added\n    // to Safari in v11. Return a noop then() so the async/await ESM code doesn't continue.\n    // IS_ESM_BUILD is replaced at build time so this check doesn't happen in systemjs builds.\n    return {\n      then() {}\n    };\n  }\n  {\n    opts.resourcesUrl = new URL('.', new URL(scriptElm.getAttribute('data-resources-url') || scriptElm.src, win.location.href)).href;\n    patchDynamicImport(opts.resourcesUrl, scriptElm);\n    if (!win.customElements) {\n      // module support, but no custom elements support (Old Edge)\n      // @ts-ignore\n      return import( /* webpackChunkName: \"stencil-polyfills-dom\" */'./dom-76cc7c7d-0a082895.js').then(() => opts);\n    }\n  }\n  return promiseResolve(opts);\n};\nconst patchDynamicImport = (base, orgScriptElm) => {\n  const importFunctionName = getDynamicImportFunction(NAMESPACE);\n  try {\n    // test if this browser supports dynamic imports\n    // There is a caching issue in V8, that breaks using import() in Function\n    // By generating a random string, we can workaround it\n    // Check https://bugs.chromium.org/p/v8/issues/detail?id=9558 for more info\n    win[importFunctionName] = new Function('w', `return import(w);//${Math.random()}`);\n  } catch (e) {\n    // this shim is specifically for browsers that do support \"esm\" imports\n    // however, they do NOT support \"dynamic\" imports\n    // basically this code is for old Edge, v18 and below\n    const moduleMap = new Map();\n    win[importFunctionName] = src => {\n      const url = new URL(src, base).href;\n      let mod = moduleMap.get(url);\n      if (!mod) {\n        const script = doc.createElement('script');\n        script.type = 'module';\n        script.crossOrigin = orgScriptElm.crossOrigin;\n        script.src = URL.createObjectURL(new Blob([`import * as m from '${url}'; window.${importFunctionName}.m = m;`], {\n          type: 'application/javascript'\n        }));\n        mod = new Promise(resolve => {\n          script.onload = () => {\n            resolve(win[importFunctionName].m);\n            script.remove();\n          };\n        });\n        moduleMap.set(url, mod);\n        doc.head.appendChild(script);\n      }\n      return mod;\n    };\n  }\n};\nconst HYDRATED_CSS = '{visibility:hidden}.hydrated{visibility:inherit}';\nconst createTime = (fnName, tagName = '') => {\n  {\n    return () => {\n      return;\n    };\n  }\n};\nconst uniqueTime = (key, measureText) => {\n  {\n    return () => {\n      return;\n    };\n  }\n};\nconst rootAppliedStyles = new WeakMap();\nconst registerStyle = (scopeId, cssText, allowCS) => {\n  let style = styles.get(scopeId);\n  if (supportsConstructibleStylesheets && allowCS) {\n    style = style || new CSSStyleSheet();\n    style.replace(cssText);\n  } else {\n    style = cssText;\n  }\n  styles.set(scopeId, style);\n};\nconst addStyle = (styleContainerNode, cmpMeta, mode, hostElm) => {\n  let scopeId = getScopeId(cmpMeta.$tagName$);\n  let style = styles.get(scopeId);\n  // if an element is NOT connected then getRootNode() will return the wrong root node\n  // so the fallback is to always use the document for the root node in those cases\n  styleContainerNode = styleContainerNode.nodeType === 11 /* DocumentFragment */ ? styleContainerNode : doc;\n  if (style) {\n    if (typeof style === 'string') {\n      styleContainerNode = styleContainerNode.head || styleContainerNode;\n      let appliedStyles = rootAppliedStyles.get(styleContainerNode);\n      let styleElm;\n      if (!appliedStyles) {\n        rootAppliedStyles.set(styleContainerNode, appliedStyles = new Set());\n      }\n      if (!appliedStyles.has(scopeId)) {\n        {\n          if (plt.$cssShim$) {\n            styleElm = plt.$cssShim$.createHostStyle(hostElm, scopeId, style, !!(cmpMeta.$flags$ & 10 /* needsScopedEncapsulation */));\n            const newScopeId = styleElm['s-sc'];\n            if (newScopeId) {\n              scopeId = newScopeId;\n              // we don't want to add this styleID to the appliedStyles Set\n              // since the cssVarShim might need to apply several different\n              // stylesheets for the same component\n              appliedStyles = null;\n            }\n          } else {\n            styleElm = doc.createElement('style');\n            styleElm.innerHTML = style;\n          }\n          styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector('link'));\n        }\n        if (appliedStyles) {\n          appliedStyles.add(scopeId);\n        }\n      }\n    } else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {\n      styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];\n    }\n  }\n  return scopeId;\n};\nconst attachStyles = (elm, cmpMeta, mode) => {\n  const endAttachStyles = createTime('attachStyles', cmpMeta.$tagName$);\n  const scopeId = addStyle(supportsShadowDom && elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, mode, elm);\n  if (cmpMeta.$flags$ & 10 /* needsScopedEncapsulation */) {\n    // only required when we're NOT using native shadow dom (slot)\n    // or this browser doesn't support native shadow dom\n    // and this host element was NOT created with SSR\n    // let's pick out the inner content for slot projection\n    // create a node to represent where the original\n    // content was first placed, which is useful later on\n    // DOM WRITE!!\n    elm['s-sc'] = scopeId;\n    elm.classList.add(scopeId + '-h');\n  }\n  endAttachStyles();\n};\nconst getScopeId = (tagName, mode) => 'sc-' + tagName;\n/**\n * Production h() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\n// const stack: any[] = [];\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;\nconst h = (nodeName, vnodeData, ...children) => {\n  let child = null;\n  let simple = false;\n  let lastSimple = false;\n  let vNodeChildren = [];\n  const walk = c => {\n    for (let i = 0; i < c.length; i++) {\n      child = c[i];\n      if (Array.isArray(child)) {\n        walk(child);\n      } else if (child != null && typeof child !== 'boolean') {\n        if (simple = typeof nodeName !== 'function' && !isComplexType(child)) {\n          child = String(child);\n        }\n        if (simple && lastSimple) {\n          // If the previous child was simple (string), we merge both\n          vNodeChildren[vNodeChildren.length - 1].$text$ += child;\n        } else {\n          // Append a new vNode, if it's text, we create a text vNode\n          vNodeChildren.push(simple ? newVNode(null, child) : child);\n        }\n        lastSimple = simple;\n      }\n    }\n  };\n  walk(children);\n  if (vnodeData) {\n    {\n      const classData = vnodeData.className || vnodeData.class;\n      if (classData) {\n        vnodeData.class = typeof classData !== 'object' ? classData : Object.keys(classData).filter(k => classData[k]).join(' ');\n      }\n    }\n  }\n  const vnode = newVNode(nodeName, null);\n  vnode.$attrs$ = vnodeData;\n  if (vNodeChildren.length > 0) {\n    vnode.$children$ = vNodeChildren;\n  }\n  return vnode;\n};\nconst newVNode = (tag, text) => {\n  const vnode = {\n    $flags$: 0,\n    $tag$: tag,\n    $text$: text,\n    $elm$: null,\n    $children$: null\n  };\n  {\n    vnode.$attrs$ = null;\n  }\n  return vnode;\n};\nconst Host = {};\nconst isHost = node => node && node.$tag$ === Host;\n/**\n * Production setAccessor() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\nconst setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {\n  if (oldValue !== newValue) {\n    let isProp = isMemberInElement(elm, memberName);\n    let ln = memberName.toLowerCase();\n    if (memberName === 'class') {\n      const classList = elm.classList;\n      const oldClasses = parseClassList(oldValue);\n      const newClasses = parseClassList(newValue);\n      classList.remove(...oldClasses.filter(c => c && !newClasses.includes(c)));\n      classList.add(...newClasses.filter(c => c && !oldClasses.includes(c)));\n    } else if (memberName === 'style') {\n      // update style attribute, css properties and values\n      {\n        for (const prop in oldValue) {\n          if (!newValue || newValue[prop] == null) {\n            if (prop.includes('-')) {\n              elm.style.removeProperty(prop);\n            } else {\n              elm.style[prop] = '';\n            }\n          }\n        }\n      }\n      for (const prop in newValue) {\n        if (!oldValue || newValue[prop] !== oldValue[prop]) {\n          if (prop.includes('-')) {\n            elm.style.setProperty(prop, newValue[prop]);\n          } else {\n            elm.style[prop] = newValue[prop];\n          }\n        }\n      }\n    } else if (memberName === 'ref') {\n      // minifier will clean this up\n      if (newValue) {\n        newValue(elm);\n      }\n    } else if (!isProp && memberName[0] === 'o' && memberName[1] === 'n') {\n      // Event Handlers\n      // so if the member name starts with \"on\" and the 3rd characters is\n      // a capital letter, and it's not already a member on the element,\n      // then we're assuming it's an event listener\n      if (memberName[2] === '-') {\n        // on- prefixed events\n        // allows to be explicit about the dom event to listen without any magic\n        // under the hood:\n        // <my-cmp on-click> // listens for \"click\"\n        // <my-cmp on-Click> // listens for \"Click\"\n        // <my-cmp on-ionChange> // listens for \"ionChange\"\n        // <my-cmp on-EVENTS> // listens for \"EVENTS\"\n        memberName = memberName.slice(3);\n      } else if (isMemberInElement(win, ln)) {\n        // standard event\n        // the JSX attribute could have been \"onMouseOver\" and the\n        // member name \"onmouseover\" is on the window's prototype\n        // so let's add the listener \"mouseover\", which is all lowercased\n        memberName = ln.slice(2);\n      } else {\n        // custom event\n        // the JSX attribute could have been \"onMyCustomEvent\"\n        // so let's trim off the \"on\" prefix and lowercase the first character\n        // and add the listener \"myCustomEvent\"\n        // except for the first character, we keep the event name case\n        memberName = ln[2] + memberName.slice(3);\n      }\n      if (oldValue) {\n        plt.rel(elm, memberName, oldValue, false);\n      }\n      if (newValue) {\n        plt.ael(elm, memberName, newValue, false);\n      }\n    } else {\n      // Set property if it exists and it's not a SVG\n      const isComplex = isComplexType(newValue);\n      if ((isProp || isComplex && newValue !== null) && !isSvg) {\n        try {\n          if (!elm.tagName.includes('-')) {\n            let n = newValue == null ? '' : newValue;\n            // Workaround for Safari, moving the <input> caret when re-assigning the same valued\n            if (memberName === 'list') {\n              isProp = false;\n              // tslint:disable-next-line: triple-equals\n            } else if (oldValue == null || elm[memberName] != n) {\n              elm[memberName] = n;\n            }\n          } else {\n            elm[memberName] = newValue;\n          }\n        } catch (e) {}\n      }\n      if (newValue == null || newValue === false) {\n        {\n          elm.removeAttribute(memberName);\n        }\n      } else if ((!isProp || flags & 4 /* isHost */ || isSvg) && !isComplex) {\n        newValue = newValue === true ? '' : newValue;\n        {\n          elm.setAttribute(memberName, newValue);\n        }\n      }\n    }\n  }\n};\nconst parseClassListRegex = /\\s/;\nconst parseClassList = value => !value ? [] : value.split(parseClassListRegex);\nconst updateElement = (oldVnode, newVnode, isSvgMode, memberName) => {\n  // if the element passed in is a shadow root, which is a document fragment\n  // then we want to be adding attrs/props to the shadow root's \"host\" element\n  // if it's not a shadow root, then we add attrs/props to the same element\n  const elm = newVnode.$elm$.nodeType === 11 /* DocumentFragment */ && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;\n  const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ;\n  const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;\n  {\n    // remove attributes no longer present on the vnode by setting them to undefined\n    for (memberName in oldVnodeAttrs) {\n      if (!(memberName in newVnodeAttrs)) {\n        setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);\n      }\n    }\n  }\n  // add new & update changed attributes\n  for (memberName in newVnodeAttrs) {\n    setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);\n  }\n};\nconst createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {\n  // tslint:disable-next-line: prefer-const\n  let newVNode = newParentVNode.$children$[childIndex];\n  let i = 0;\n  let elm;\n  let childNode;\n  if (newVNode.$text$ !== null) {\n    // create text node\n    elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);\n  } else {\n    if (!isSvgMode) {\n      isSvgMode = newVNode.$tag$ === 'svg';\n    }\n    // create element\n    elm = newVNode.$elm$ = doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, newVNode.$tag$);\n    if (isSvgMode && newVNode.$tag$ === 'foreignObject') {\n      isSvgMode = false;\n    }\n    // add css classes, attrs, props, listeners, etc.\n    {\n      updateElement(null, newVNode, isSvgMode);\n    }\n    if (isDef(scopeId) && elm['s-si'] !== scopeId) {\n      // if there is a scopeId and this is the initial render\n      // then let's add the scopeId as a css class\n      elm.classList.add(elm['s-si'] = scopeId);\n    }\n    if (newVNode.$children$) {\n      for (i = 0; i < newVNode.$children$.length; ++i) {\n        // create the node\n        childNode = createElm(oldParentVNode, newVNode, i);\n        // return node could have been null\n        if (childNode) {\n          // append our new node\n          elm.appendChild(childNode);\n        }\n      }\n    }\n    {\n      if (newVNode.$tag$ === 'svg') {\n        // Only reset the SVG context when we're exiting <svg> element\n        isSvgMode = false;\n      } else if (elm.tagName === 'foreignObject') {\n        // Reenter SVG context when we're exiting <foreignObject> element\n        isSvgMode = true;\n      }\n    }\n  }\n  return elm;\n};\nconst addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {\n  let containerElm = parentElm;\n  let childNode;\n  if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {\n    containerElm = containerElm.shadowRoot;\n  }\n  for (; startIdx <= endIdx; ++startIdx) {\n    if (vnodes[startIdx]) {\n      childNode = createElm(null, parentVNode, startIdx);\n      if (childNode) {\n        vnodes[startIdx].$elm$ = childNode;\n        containerElm.insertBefore(childNode, before);\n      }\n    }\n  }\n};\nconst removeVnodes = (vnodes, startIdx, endIdx, vnode, elm) => {\n  for (; startIdx <= endIdx; ++startIdx) {\n    if (vnode = vnodes[startIdx]) {\n      elm = vnode.$elm$;\n      callNodeRefs(vnode);\n      // remove the vnode's element from the dom\n      elm.remove();\n    }\n  }\n};\nconst updateChildren = (parentElm, oldCh, newVNode, newCh) => {\n  let oldStartIdx = 0;\n  let newStartIdx = 0;\n  let oldEndIdx = oldCh.length - 1;\n  let oldStartVnode = oldCh[0];\n  let oldEndVnode = oldCh[oldEndIdx];\n  let newEndIdx = newCh.length - 1;\n  let newStartVnode = newCh[0];\n  let newEndVnode = newCh[newEndIdx];\n  let node;\n  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n    if (oldStartVnode == null) {\n      // Vnode might have been moved left\n      oldStartVnode = oldCh[++oldStartIdx];\n    } else if (oldEndVnode == null) {\n      oldEndVnode = oldCh[--oldEndIdx];\n    } else if (newStartVnode == null) {\n      newStartVnode = newCh[++newStartIdx];\n    } else if (newEndVnode == null) {\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldStartVnode, newStartVnode)) {\n      patch(oldStartVnode, newStartVnode);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else if (isSameVnode(oldEndVnode, newEndVnode)) {\n      patch(oldEndVnode, newEndVnode);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldStartVnode, newEndVnode)) {\n      patch(oldStartVnode, newEndVnode);\n      parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldEndVnode, newStartVnode)) {\n      patch(oldEndVnode, newStartVnode);\n      parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else {\n      {\n        // new element\n        node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx);\n        newStartVnode = newCh[++newStartIdx];\n      }\n      if (node) {\n        {\n          oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);\n        }\n      }\n    }\n  }\n  if (oldStartIdx > oldEndIdx) {\n    addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);\n  } else if (newStartIdx > newEndIdx) {\n    removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n  }\n};\nconst isSameVnode = (vnode1, vnode2) => {\n  // compare if two vnode to see if they're \"technically\" the same\n  // need to have the same element tag, and same key to be the same\n  if (vnode1.$tag$ === vnode2.$tag$) {\n    return true;\n  }\n  return false;\n};\nconst patch = (oldVNode, newVNode) => {\n  const elm = newVNode.$elm$ = oldVNode.$elm$;\n  const oldChildren = oldVNode.$children$;\n  const newChildren = newVNode.$children$;\n  const tag = newVNode.$tag$;\n  const text = newVNode.$text$;\n  if (text === null) {\n    {\n      // test if we're rendering an svg element, or still rendering nodes inside of one\n      // only add this to the when the compiler sees we're using an svg somewhere\n      isSvgMode = tag === 'svg' ? true : tag === 'foreignObject' ? false : isSvgMode;\n    }\n    // element node\n    {\n      {\n        // either this is the first render of an element OR it's an update\n        // AND we already know it's possible it could have changed\n        // this updates the element's css classes, attrs, props, listeners, etc.\n        updateElement(oldVNode, newVNode, isSvgMode);\n      }\n    }\n    if (oldChildren !== null && newChildren !== null) {\n      // looks like there's child vnodes for both the old and new vnodes\n      updateChildren(elm, oldChildren, newVNode, newChildren);\n    } else if (newChildren !== null) {\n      // no old child vnodes, but there are new child vnodes to add\n      if (oldVNode.$text$ !== null) {\n        // the old vnode was text, so be sure to clear it out\n        elm.textContent = '';\n      }\n      // add the new vnode children\n      addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);\n    } else if (oldChildren !== null) {\n      // no new child vnodes, but there are old child vnodes to remove\n      removeVnodes(oldChildren, 0, oldChildren.length - 1);\n    }\n    if (isSvgMode && tag === 'svg') {\n      isSvgMode = false;\n    }\n  } else if (oldVNode.$text$ !== text) {\n    // update the text content for the text only vnode\n    // and also only if the text is different than before\n    elm.data = text;\n  }\n};\nconst callNodeRefs = vNode => {\n  {\n    vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);\n    vNode.$children$ && vNode.$children$.forEach(callNodeRefs);\n  }\n};\nconst renderVdom = (hostElm, hostRef, cmpMeta, renderFnResults) => {\n  hostTagName = hostElm.tagName;\n  const oldVNode = hostRef.$vnode$ || newVNode(null, null);\n  const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);\n  rootVnode.$tag$ = null;\n  rootVnode.$flags$ |= 4 /* isHost */;\n  hostRef.$vnode$ = rootVnode;\n  rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm;\n  {\n    scopeId = hostElm['s-sc'];\n  }\n  // synchronous patch\n  patch(oldVNode, rootVnode);\n};\nconst attachToAncestor = (hostRef, ancestorComponent) => {\n  if (ancestorComponent && !hostRef.$onRenderResolve$) {\n    ancestorComponent['s-p'].push(new Promise(r => hostRef.$onRenderResolve$ = r));\n  }\n};\nconst scheduleUpdate = (elm, hostRef, cmpMeta, isInitialLoad) => {\n  {\n    hostRef.$flags$ |= 16 /* isQueuedForUpdate */;\n  }\n\n  if (hostRef.$flags$ & 4 /* isWaitingForChildren */) {\n    hostRef.$flags$ |= 512 /* needsRerender */;\n    return;\n  }\n  const endSchedule = createTime('scheduleUpdate', cmpMeta.$tagName$);\n  const ancestorComponent = hostRef.$ancestorComponent$;\n  const instance = hostRef.$lazyInstance$;\n  const update = () => updateComponent(elm, hostRef, cmpMeta, instance, isInitialLoad);\n  attachToAncestor(hostRef, ancestorComponent);\n  let promise;\n  if (isInitialLoad) {\n    {\n      hostRef.$flags$ |= 256 /* isListenReady */;\n      if (hostRef.$queuedListeners$) {\n        hostRef.$queuedListeners$.forEach(([methodName, event]) => safeCall(instance, methodName, event));\n        hostRef.$queuedListeners$ = null;\n      }\n    }\n  }\n  endSchedule();\n  // there is no ancestorc omponent or the ancestor component\n  // has already fired off its lifecycle update then\n  // fire off the initial update\n  return then(promise, () => writeTask(update));\n};\nconst updateComponent = (elm, hostRef, cmpMeta, instance, isInitialLoad) => {\n  // updateComponent\n  const endUpdate = createTime('update', cmpMeta.$tagName$);\n  const rc = elm['s-rc'];\n  if (isInitialLoad) {\n    // DOM WRITE!\n    attachStyles(elm, cmpMeta, hostRef.$modeName$);\n  }\n  const endRender = createTime('render', cmpMeta.$tagName$);\n  {\n    {\n      // looks like we've got child nodes to render into this host element\n      // or we need to update the css class/attrs on the host element\n      // DOM WRITE!\n      renderVdom(elm, hostRef, cmpMeta, callRender(instance));\n    }\n  }\n  if (plt.$cssShim$) {\n    plt.$cssShim$.updateHost(elm);\n  }\n  {\n    hostRef.$flags$ &= ~16 /* isQueuedForUpdate */;\n  }\n\n  {\n    hostRef.$flags$ |= 2 /* hasRendered */;\n  }\n\n  if (rc) {\n    // ok, so turns out there are some child host elements\n    // waiting on this parent element to load\n    // let's fire off all update callbacks waiting\n    rc.forEach(cb => cb());\n    elm['s-rc'] = undefined;\n  }\n  endRender();\n  endUpdate();\n  {\n    const childrenPromises = elm['s-p'];\n    const postUpdate = () => postUpdateComponent(elm, hostRef, cmpMeta);\n    if (childrenPromises.length === 0) {\n      postUpdate();\n    } else {\n      Promise.all(childrenPromises).then(postUpdate);\n      hostRef.$flags$ |= 4 /* isWaitingForChildren */;\n      childrenPromises.length = 0;\n    }\n  }\n};\nconst callRender = (instance, elm) => {\n  try {\n    instance = instance.render();\n  } catch (e) {\n    consoleError(e);\n  }\n  return instance;\n};\nconst postUpdateComponent = (elm, hostRef, cmpMeta) => {\n  const endPostUpdate = createTime('postUpdate', cmpMeta.$tagName$);\n  const instance = hostRef.$lazyInstance$;\n  const ancestorComponent = hostRef.$ancestorComponent$;\n  if (!(hostRef.$flags$ & 64 /* hasLoadedComponent */)) {\n    hostRef.$flags$ |= 64 /* hasLoadedComponent */;\n    {\n      // DOM WRITE!\n      addHydratedFlag(elm);\n    }\n    {\n      safeCall(instance, 'componentDidLoad');\n    }\n    endPostUpdate();\n    {\n      hostRef.$onReadyResolve$(elm);\n      if (!ancestorComponent) {\n        appDidLoad();\n      }\n    }\n  } else {\n    endPostUpdate();\n  }\n  {\n    hostRef.$onInstanceResolve$(elm);\n  }\n  // load events fire from bottom to top\n  // the deepest elements load first then bubbles up\n  {\n    if (hostRef.$onRenderResolve$) {\n      hostRef.$onRenderResolve$();\n      hostRef.$onRenderResolve$ = undefined;\n    }\n    if (hostRef.$flags$ & 512 /* needsRerender */) {\n      nextTick(() => scheduleUpdate(elm, hostRef, cmpMeta, false));\n    }\n    hostRef.$flags$ &= ~(4 /* isWaitingForChildren */ | 512 /* needsRerender */);\n  }\n  // ( •_•)\n  // ( •_•)>⌐■-■\n  // (⌐■_■)\n};\n\nconst forceUpdate = (elm, cmpMeta) => {\n  {\n    const hostRef = getHostRef(elm);\n    const isConnected = hostRef.$hostElement$.isConnected;\n    if (isConnected && (hostRef.$flags$ & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\n      scheduleUpdate(elm, hostRef, cmpMeta, false);\n    }\n    // Returns \"true\" when the forced update was successfully scheduled\n    return isConnected;\n  }\n};\nconst appDidLoad = who => {\n  // on appload\n  // we have finish the first big initial render\n  {\n    addHydratedFlag(doc.documentElement);\n  }\n  {\n    plt.$flags$ |= 2 /* appLoaded */;\n  }\n};\n\nconst safeCall = (instance, method, arg) => {\n  if (instance && instance[method]) {\n    try {\n      return instance[method](arg);\n    } catch (e) {\n      consoleError(e);\n    }\n  }\n  return undefined;\n};\nconst then = (promise, thenFn) => {\n  return promise && promise.then ? promise.then(thenFn) : thenFn();\n};\nconst addHydratedFlag = elm => elm.classList.add('hydrated');\nconst addEventListeners = (elm, hostRef, listeners) => {\n  hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || [];\n  const removeFns = listeners.map(([flags, name, method]) => {\n    const target = getHostListenerTarget(elm, flags);\n    const handler = hostListenerProxy(hostRef, method);\n    const opts = hostListenerOpts(flags);\n    plt.ael(target, name, handler, opts);\n    return () => plt.rel(target, name, handler, opts);\n  });\n  return () => removeFns.forEach(fn => fn());\n};\nconst hostListenerProxy = (hostRef, methodName) => {\n  return ev => {\n    {\n      if (hostRef.$flags$ & 256 /* isListenReady */) {\n        // instance is ready, let's call it's member method for this event\n        hostRef.$lazyInstance$[methodName](ev);\n      } else {\n        hostRef.$queuedListeners$.push([methodName, ev]);\n      }\n    }\n  };\n};\nconst getHostListenerTarget = (elm, flags) => {\n  if (flags & 32 /* TargetBody */) return doc.body;\n  return elm;\n};\nconst hostListenerOpts = flags => (flags & 2 /* Capture */) !== 0;\nconst parsePropertyValue = (propValue, propType) => {\n  // ensure this value is of the correct prop type\n  if (propValue != null && !isComplexType(propValue)) {\n    if (propType & 4 /* Boolean */) {\n      // per the HTML spec, any string value means it is a boolean true value\n      // but we'll cheat here and say that the string \"false\" is the boolean false\n      return propValue === 'false' ? false : propValue === '' || !!propValue;\n    }\n    if (propType & 2 /* Number */) {\n      // force it to be a number\n      return parseFloat(propValue);\n    }\n    if (propType & 1 /* String */) {\n      // could have been passed as a number or boolean\n      // but we still want it as a string\n      return String(propValue);\n    }\n    // redundant return here for better minification\n    return propValue;\n  }\n  // not sure exactly what type we want\n  // so no need to change to a different type\n  return propValue;\n};\nconst getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);\nconst setValue = (ref, propName, newVal, cmpMeta) => {\n  // check our new property value against our internal value\n  const hostRef = getHostRef(ref);\n  const elm = hostRef.$hostElement$;\n  const oldVal = hostRef.$instanceValues$.get(propName);\n  const flags = hostRef.$flags$;\n  const instance = hostRef.$lazyInstance$;\n  newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);\n  if (newVal !== oldVal && (!(flags & 8 /* isConstructingInstance */) || oldVal === undefined)) {\n    // gadzooks! the property's value has changed!!\n    // set our new value!\n    hostRef.$instanceValues$.set(propName, newVal);\n    if (instance) {\n      if ((flags & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\n        // looks like this value actually changed, so we've got work to do!\n        // but only if we've already rendered, otherwise just chill out\n        // queue that we need to do an update, but don't worry about queuing\n        // up millions cuz this function ensures it only runs once\n        scheduleUpdate(elm, hostRef, cmpMeta, false);\n      }\n    }\n  }\n};\nconst proxyComponent = (Cstr, cmpMeta, flags) => {\n  if (cmpMeta.$members$) {\n    // It's better to have a const than two Object.entries()\n    const members = Object.entries(cmpMeta.$members$);\n    const prototype = Cstr.prototype;\n    members.forEach(([memberName, [memberFlags]]) => {\n      if (memberFlags & 31 /* Prop */ || flags & 2 /* proxyState */ && memberFlags & 32 /* State */) {\n        // proxyComponent - prop\n        Object.defineProperty(prototype, memberName, {\n          get() {\n            // proxyComponent, get value\n            return getValue(this, memberName);\n          },\n          set(newValue) {\n            // proxyComponent, set value\n            setValue(this, memberName, newValue, cmpMeta);\n          },\n          configurable: true,\n          enumerable: true\n        });\n      } else if (flags & 1 /* isElementConstructor */ && memberFlags & 64 /* Method */) {\n        // proxyComponent - method\n        Object.defineProperty(prototype, memberName, {\n          value(...args) {\n            const ref = getHostRef(this);\n            return ref.$onInstancePromise$.then(() => ref.$lazyInstance$[memberName](...args));\n          }\n        });\n      }\n    });\n    if (flags & 1 /* isElementConstructor */) {\n      const attrNameToPropName = new Map();\n      prototype.attributeChangedCallback = function (attrName, _oldValue, newValue) {\n        plt.jmp(() => {\n          const propName = attrNameToPropName.get(attrName);\n          this[propName] = newValue === null && typeof this[propName] === 'boolean' ? false : newValue;\n        });\n      };\n      // create an array of attributes to observe\n      // and also create a map of html attribute name to js property name\n      Cstr.observedAttributes = members.filter(([_, m]) => m[0] & 15 /* HasAttribute */) // filter to only keep props that should match attributes\n      .map(([propName, m]) => {\n        const attrName = m[1] || propName;\n        attrNameToPropName.set(attrName, propName);\n        return attrName;\n      });\n    }\n  }\n  return Cstr;\n};\nconst initializeComponent = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (elm, hostRef, cmpMeta, hmrVersionId, Cstr) {\n    // initializeComponent\n    if ((hostRef.$flags$ & 32 /* hasInitializedComponent */) === 0) {\n      // we haven't initialized this element yet\n      hostRef.$flags$ |= 32 /* hasInitializedComponent */;\n      {\n        // lazy loaded components\n        // request the component's implementation to be\n        // wired up with the host element\n        Cstr = loadModule(cmpMeta);\n        if (Cstr.then) {\n          // Await creates a micro-task avoid if possible\n          const endLoad = uniqueTime();\n          Cstr = yield Cstr;\n          endLoad();\n        }\n        if (!Cstr.isProxied) {\n          proxyComponent(Cstr, cmpMeta, 2 /* proxyState */);\n          Cstr.isProxied = true;\n        }\n        const endNewInstance = createTime('createInstance', cmpMeta.$tagName$);\n        // ok, time to construct the instance\n        // but let's keep track of when we start and stop\n        // so that the getters/setters don't incorrectly step on data\n        {\n          hostRef.$flags$ |= 8 /* isConstructingInstance */;\n        }\n        // construct the lazy-loaded component implementation\n        // passing the hostRef is very important during\n        // construction in order to directly wire together the\n        // host element and the lazy-loaded instance\n        try {\n          new Cstr(hostRef);\n        } catch (e) {\n          consoleError(e);\n        }\n        {\n          hostRef.$flags$ &= ~8 /* isConstructingInstance */;\n        }\n\n        endNewInstance();\n      }\n      const scopeId = getScopeId(cmpMeta.$tagName$);\n      if (!styles.has(scopeId) && Cstr.style) {\n        const endRegisterStyles = createTime('registerStyles', cmpMeta.$tagName$);\n        // this component has styles but we haven't registered them yet\n        let style = Cstr.style;\n        if (cmpMeta.$flags$ & 8 /* needsShadowDomShim */) {\n          style = yield import('./shadow-css-d7d058ec-d59cb009.js').then(m => m.scopeCss(style, scopeId, false));\n        }\n        registerStyle(scopeId, style, !!(cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */));\n        endRegisterStyles();\n      }\n    }\n    // we've successfully created a lazy instance\n    const ancestorComponent = hostRef.$ancestorComponent$;\n    const schedule = () => scheduleUpdate(elm, hostRef, cmpMeta, true);\n    if (ancestorComponent && ancestorComponent['s-rc']) {\n      // this is the intial load and this component it has an ancestor component\n      // but the ancestor component has NOT fired its will update lifecycle yet\n      // so let's just cool our jets and wait for the ancestor to continue first\n      // this will get fired off when the ancestor component\n      // finally gets around to rendering its lazy self\n      // fire off the initial update\n      ancestorComponent['s-rc'].push(schedule);\n    } else {\n      schedule();\n    }\n  });\n  return function initializeComponent(_x, _x2, _x3, _x4, _x5) {\n    return _ref.apply(this, arguments);\n  };\n}();\nconst connectedCallback = (elm, cmpMeta) => {\n  if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n    const endConnected = createTime('connectedCallback', cmpMeta.$tagName$);\n    // connectedCallback\n    const hostRef = getHostRef(elm);\n    if (cmpMeta.$listeners$) {\n      // initialize our event listeners on the host element\n      // we do this now so that we can listening to events that may\n      // have fired even before the instance is ready\n      hostRef.$rmListeners$ = addEventListeners(elm, hostRef, cmpMeta.$listeners$);\n    }\n    if (!(hostRef.$flags$ & 1 /* hasConnected */)) {\n      // first time this component has connected\n      hostRef.$flags$ |= 1 /* hasConnected */;\n      {\n        // find the first ancestor component (if there is one) and register\n        // this component as one of the actively loading child components for its ancestor\n        let ancestorComponent = elm;\n        while (ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host) {\n          // climb up the ancestors looking for the first\n          // component that hasn't finished its lifecycle update yet\n          if (ancestorComponent['s-p']) {\n            // we found this components first ancestor component\n            // keep a reference to this component's ancestor component\n            attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);\n            break;\n          }\n        }\n      }\n      // Lazy properties\n      // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n      if (cmpMeta.$members$) {\n        Object.entries(cmpMeta.$members$).forEach(([memberName, [memberFlags]]) => {\n          if (memberFlags & 31 /* Prop */ && elm.hasOwnProperty(memberName)) {\n            const value = elm[memberName];\n            delete elm[memberName];\n            elm[memberName] = value;\n          }\n        });\n      }\n      {\n        // connectedCallback, taskQueue, initialLoad\n        // angular sets attribute AFTER connectCallback\n        // https://github.com/angular/angular/issues/18909\n        // https://github.com/angular/angular/issues/19940\n        nextTick(() => initializeComponent(elm, hostRef, cmpMeta));\n      }\n    }\n    endConnected();\n  }\n};\nconst disconnectedCallback = elm => {\n  if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n    const hostRef = getHostRef(elm);\n    const instance = hostRef.$lazyInstance$;\n    {\n      if (hostRef.$rmListeners$) {\n        hostRef.$rmListeners$();\n        hostRef.$rmListeners$ = undefined;\n      }\n    }\n    // clear CSS var-shim tracking\n    if (plt.$cssShim$) {\n      plt.$cssShim$.removeHost(elm);\n    }\n    {\n      safeCall(instance, 'componentDidUnload');\n    }\n  }\n};\nconst bootstrapLazy = (lazyBundles, options = {}) => {\n  const endBootstrap = createTime();\n  const cmpTags = [];\n  const exclude = options.exclude || [];\n  const customElements = win.customElements;\n  const head = doc.head;\n  const metaCharset = /*@__PURE__*/head.querySelector('meta[charset]');\n  const visibilityStyle = /*@__PURE__*/doc.createElement('style');\n  const deferredConnectedCallbacks = [];\n  let appLoadFallback;\n  let isBootstrapping = true;\n  Object.assign(plt, options);\n  plt.$resourcesUrl$ = new URL(options.resourcesUrl || './', doc.baseURI).href;\n  if (options.syncQueue) {\n    plt.$flags$ |= 4 /* queueSync */;\n  }\n\n  lazyBundles.forEach(lazyBundle => lazyBundle[1].forEach(compactMeta => {\n    const cmpMeta = {\n      $flags$: compactMeta[0],\n      $tagName$: compactMeta[1],\n      $members$: compactMeta[2],\n      $listeners$: compactMeta[3]\n    };\n    {\n      cmpMeta.$members$ = compactMeta[2];\n    }\n    {\n      cmpMeta.$listeners$ = compactMeta[3];\n    }\n    if (!supportsShadowDom && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n      cmpMeta.$flags$ |= 8 /* needsShadowDomShim */;\n    }\n\n    const tagName = cmpMeta.$tagName$;\n    const HostElement = class extends HTMLElement {\n      // StencilLazyHost\n      constructor(self) {\n        // @ts-ignore\n        super(self);\n        self = this;\n        registerHost(self);\n        if (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n          // this component is using shadow dom\n          // and this browser supports shadow dom\n          // add the read-only property \"shadowRoot\" to the host element\n          // adding the shadow root build conditionals to minimize runtime\n          if (supportsShadowDom) {\n            {\n              self.attachShadow({\n                mode: 'open'\n              });\n            }\n          } else if (!('shadowRoot' in self)) {\n            self.shadowRoot = self;\n          }\n        }\n      }\n      connectedCallback() {\n        if (appLoadFallback) {\n          clearTimeout(appLoadFallback);\n          appLoadFallback = null;\n        }\n        if (isBootstrapping) {\n          // connectedCallback will be processed once all components have been registered\n          deferredConnectedCallbacks.push(this);\n        } else {\n          plt.jmp(() => connectedCallback(this, cmpMeta));\n        }\n      }\n      disconnectedCallback() {\n        plt.jmp(() => disconnectedCallback(this));\n      }\n      forceUpdate() {\n        forceUpdate(this, cmpMeta);\n      }\n      componentOnReady() {\n        return getHostRef(this).$onReadyPromise$;\n      }\n    };\n    cmpMeta.$lazyBundleIds$ = lazyBundle[0];\n    if (!exclude.includes(tagName) && !customElements.get(tagName)) {\n      cmpTags.push(tagName);\n      customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1 /* isElementConstructor */));\n    }\n  }));\n\n  {\n    visibilityStyle.innerHTML = cmpTags + HYDRATED_CSS;\n    visibilityStyle.setAttribute('data-styles', '');\n    head.insertBefore(visibilityStyle, metaCharset ? metaCharset.nextSibling : head.firstChild);\n  }\n  // Process deferred connectedCallbacks now all components have been registered\n  isBootstrapping = false;\n  if (deferredConnectedCallbacks.length > 0) {\n    deferredConnectedCallbacks.forEach(host => host.connectedCallback());\n  } else {\n    {\n      plt.jmp(() => appLoadFallback = setTimeout(appDidLoad, 30));\n    }\n  }\n  // Fallback appLoad event\n  endBootstrap();\n};\nconst createEvent = (ref, name, flags) => {\n  const elm = getElement(ref);\n  return {\n    emit: detail => {\n      const ev = new CustomEvent(name, {\n        bubbles: !!(flags & 4 /* Bubbles */),\n        composed: !!(flags & 2 /* Composed */),\n        cancelable: !!(flags & 1 /* Cancellable */),\n        detail\n      });\n      elm.dispatchEvent(ev);\n      return ev;\n    }\n  };\n};\nconst getAssetPath = path => {\n  const assetUrl = new URL(path, plt.$resourcesUrl$);\n  return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;\n};\nconst getContext = (_elm, context) => {\n  if (context in Context) {\n    return Context[context];\n  } else if (context === 'window') {\n    return win;\n  } else if (context === 'document') {\n    return doc;\n  } else if (context === 'isServer' || context === 'isPrerender') {\n    return false;\n  } else if (context === 'isClient') {\n    return true;\n  } else if (context === 'resourcesUrl' || context === 'publicPath') {\n    return getAssetPath('.');\n  } else if (context === 'queue') {\n    return {\n      write: writeTask,\n      read: readTask,\n      tick: {\n        then(cb) {\n          return nextTick(cb);\n        }\n      }\n    };\n  }\n  return undefined;\n};\nconst getElement = ref => getHostRef(ref).$hostElement$;\nexport { Host as H, patchEsm as a, bootstrapLazy as b, createEvent as c, getContext as d, getElement as g, h, patchBrowser as p, registerInstance as r };","map":{"version":3,"names":["NAMESPACE","queueCongestion","queuePending","scopeId","hostTagName","isSvgMode","win","window","CSS","doc","document","head","plt","$flags$","$resourcesUrl$","jmp","h","raf","requestAnimationFrame","ael","el","eventName","listener","opts","addEventListener","rel","removeEventListener","supportsShadowDom","attachShadow","indexOf","promiseResolve","v","Promise","resolve","supportsConstructibleStylesheets","CSSStyleSheet","e","Context","hostRefs","WeakMap","getHostRef","ref","get","registerInstance","lazyInstance","hostRef","set","$lazyInstance$","registerHost","elm","$hostElement$","$instanceValues$","Map","$onInstancePromise$","r","$onInstanceResolve$","$onReadyPromise$","$onReadyResolve$","isMemberInElement","memberName","consoleError","console","error","moduleCache","loadModule","cmpMeta","hmrVersionId","exportName","$tagName$","replace","bundleId","$lazyBundleIds$","module","then","importedModule","styles","queueDomReads","queueDomWrites","queueDomWritesLow","queueTask","queue","write","cb","push","nextTick","flush","consume","i","length","performance","now","consumeTimeout","timeout","ts","splice","Math","ceil","Infinity","readTask","writeTask","EMPTY_OBJ","SVG_NS","HTML_NS","isDef","isComplexType","o","getDynamicImportFunction","namespace","patchEsm","supports","$cssShim$","__cssshim","patchBrowser","scriptElm","Array","from","querySelectorAll","find","s","RegExp","test","src","getAttribute","history","scrollRestoration","resourcesUrl","URL","location","href","patchDynamicImport","customElements","base","orgScriptElm","importFunctionName","Function","random","moduleMap","url","mod","script","createElement","type","crossOrigin","createObjectURL","Blob","onload","m","remove","appendChild","HYDRATED_CSS","createTime","fnName","tagName","uniqueTime","key","measureText","rootAppliedStyles","registerStyle","cssText","allowCS","style","addStyle","styleContainerNode","mode","hostElm","getScopeId","nodeType","appliedStyles","styleElm","Set","has","createHostStyle","newScopeId","innerHTML","insertBefore","querySelector","add","adoptedStyleSheets","includes","attachStyles","endAttachStyles","shadowRoot","getRootNode","classList","nodeName","vnodeData","children","child","simple","lastSimple","vNodeChildren","walk","c","isArray","String","$text$","newVNode","classData","className","class","Object","keys","filter","k","join","vnode","$attrs$","$children$","tag","text","$tag$","$elm$","Host","isHost","node","setAccessor","oldValue","newValue","isSvg","flags","isProp","ln","toLowerCase","oldClasses","parseClassList","newClasses","prop","removeProperty","setProperty","slice","isComplex","n","removeAttribute","setAttribute","parseClassListRegex","value","split","updateElement","oldVnode","newVnode","host","oldVnodeAttrs","newVnodeAttrs","undefined","createElm","oldParentVNode","newParentVNode","childIndex","parentElm","childNode","createTextNode","createElementNS","addVnodes","before","parentVNode","vnodes","startIdx","endIdx","containerElm","removeVnodes","callNodeRefs","updateChildren","oldCh","newCh","oldStartIdx","newStartIdx","oldEndIdx","oldStartVnode","oldEndVnode","newEndIdx","newStartVnode","newEndVnode","isSameVnode","patch","nextSibling","parentNode","vnode1","vnode2","oldVNode","oldChildren","newChildren","textContent","data","vNode","forEach","renderVdom","renderFnResults","$vnode$","rootVnode","attachToAncestor","ancestorComponent","$onRenderResolve$","scheduleUpdate","isInitialLoad","endSchedule","$ancestorComponent$","instance","update","updateComponent","promise","$queuedListeners$","methodName","event","safeCall","endUpdate","rc","$modeName$","endRender","callRender","updateHost","childrenPromises","postUpdate","postUpdateComponent","all","render","endPostUpdate","addHydratedFlag","appDidLoad","forceUpdate","isConnected","who","documentElement","method","arg","thenFn","addEventListeners","listeners","removeFns","map","name","target","getHostListenerTarget","handler","hostListenerProxy","hostListenerOpts","fn","ev","body","parsePropertyValue","propValue","propType","parseFloat","getValue","propName","setValue","newVal","oldVal","$members$","proxyComponent","Cstr","members","entries","prototype","memberFlags","defineProperty","configurable","enumerable","args","attrNameToPropName","attributeChangedCallback","attrName","_oldValue","observedAttributes","_","initializeComponent","endLoad","isProxied","endNewInstance","endRegisterStyles","scopeCss","schedule","connectedCallback","endConnected","$listeners$","$rmListeners$","hasOwnProperty","disconnectedCallback","removeHost","bootstrapLazy","lazyBundles","options","endBootstrap","cmpTags","exclude","metaCharset","visibilityStyle","deferredConnectedCallbacks","appLoadFallback","isBootstrapping","assign","baseURI","syncQueue","lazyBundle","compactMeta","HostElement","HTMLElement","constructor","self","clearTimeout","componentOnReady","define","firstChild","setTimeout","createEvent","getElement","emit","detail","CustomEvent","bubbles","composed","cancelable","dispatchEvent","getAssetPath","path","assetUrl","origin","pathname","getContext","_elm","context","read","tick","H","a","b","d","g","p"],"sources":["/home/digifemmes-22lab149/Bureau/soutramoi_app/node_modules/@ionic/pwa-elements/dist/esm/core-f86805ad.js"],"sourcesContent":["const NAMESPACE = 'ionicpwaelements';\n\nlet queueCongestion = 0;\nlet queuePending = false;\nlet scopeId;\nlet hostTagName;\nlet isSvgMode = false;\nconst win = typeof window !== 'undefined' ? window : {};\nconst CSS =  win.CSS ;\nconst doc = win.document || { head: {} };\nconst plt = {\n    $flags$: 0,\n    $resourcesUrl$: '',\n    jmp: (h) => h(),\n    raf: (h) => requestAnimationFrame(h),\n    ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),\n    rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),\n};\nconst supportsShadowDom =   /*@__PURE__*/ (() => (doc.head.attachShadow + '').indexOf('[native') > -1)()  ;\nconst promiseResolve = (v) => Promise.resolve(v);\nconst supportsConstructibleStylesheets =  /*@__PURE__*/ (() => {\n    try {\n        new CSSStyleSheet();\n        return true;\n    }\n    catch (e) { }\n    return false;\n})() ;\nconst Context = {};\nconst hostRefs = new WeakMap();\nconst getHostRef = (ref) => hostRefs.get(ref);\nconst registerInstance = (lazyInstance, hostRef) => hostRefs.set(hostRef.$lazyInstance$ = lazyInstance, hostRef);\nconst registerHost = (elm) => {\n    const hostRef = {\n        $flags$: 0,\n        $hostElement$: elm,\n        $instanceValues$: new Map()\n    };\n    {\n        hostRef.$onInstancePromise$ = new Promise(r => hostRef.$onInstanceResolve$ = r);\n    }\n    {\n        hostRef.$onReadyPromise$ = new Promise(r => hostRef.$onReadyResolve$ = r);\n        elm['s-p'] = [];\n        elm['s-rc'] = [];\n    }\n    return hostRefs.set(elm, hostRef);\n};\nconst isMemberInElement = (elm, memberName) => memberName in elm;\nconst consoleError = (e) => console.error(e);\nconst moduleCache = /*@__PURE__*/ new Map();\nconst loadModule = (cmpMeta, hostRef, hmrVersionId) => {\n    // loadModuleImport\n    const exportName = cmpMeta.$tagName$.replace(/-/g, '_');\n    const bundleId = ( cmpMeta.$lazyBundleIds$);\n    const module =  moduleCache.get(bundleId) ;\n    if (module) {\n        return module[exportName];\n    }\n    return import(\n    /* webpackInclude: /\\.entry\\.js$/ */\n    /* webpackExclude: /\\.system\\.entry\\.js$/ */\n    /* webpackMode: \"lazy\" */\n    `./${bundleId}.entry.js${ ''}`).then(importedModule => {\n        {\n            moduleCache.set(bundleId, importedModule);\n        }\n        return importedModule[exportName];\n    }, consoleError);\n};\nconst styles = new Map();\nconst queueDomReads = [];\nconst queueDomWrites = [];\nconst queueDomWritesLow = [];\nconst queueTask = (queue, write) => (cb) => {\n    queue.push(cb);\n    if (!queuePending) {\n        queuePending = true;\n        if (write && plt.$flags$ & 4 /* queueSync */) {\n            nextTick(flush);\n        }\n        else {\n            plt.raf(flush);\n        }\n    }\n};\nconst consume = (queue) => {\n    for (let i = 0; i < queue.length; i++) {\n        try {\n            queue[i](performance.now());\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    queue.length = 0;\n};\nconst consumeTimeout = (queue, timeout) => {\n    let i = 0;\n    let ts = 0;\n    while (i < queue.length && (ts = performance.now()) < timeout) {\n        try {\n            queue[i++](ts);\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    if (i === queue.length) {\n        queue.length = 0;\n    }\n    else if (i !== 0) {\n        queue.splice(0, i);\n    }\n};\nconst flush = () => {\n    queueCongestion++;\n    // always force a bunch of medium callbacks to run, but still have\n    // a throttle on how many can run in a certain time\n    // DOM READS!!!\n    consume(queueDomReads);\n    const timeout = (plt.$flags$ & 6 /* queueMask */) === 2 /* appLoaded */\n        ? performance.now() + (10 * Math.ceil(queueCongestion * (1.0 / 22.0)))\n        : Infinity;\n    // DOM WRITES!!!\n    consumeTimeout(queueDomWrites, timeout);\n    consumeTimeout(queueDomWritesLow, timeout);\n    if (queueDomWrites.length > 0) {\n        queueDomWritesLow.push(...queueDomWrites);\n        queueDomWrites.length = 0;\n    }\n    if (queuePending = ((queueDomReads.length + queueDomWrites.length + queueDomWritesLow.length) > 0)) {\n        // still more to do yet, but we've run out of time\n        // let's let this thing cool off and try again in the next tick\n        plt.raf(flush);\n    }\n    else {\n        queueCongestion = 0;\n    }\n};\nconst nextTick = /*@__PURE__*/ (cb) => promiseResolve().then(cb);\nconst readTask = /*@__PURE__*/ queueTask(queueDomReads, false);\nconst writeTask = /*@__PURE__*/ queueTask(queueDomWrites, true);\n/**\n * Default style mode id\n */\n/**\n * Reusable empty obj/array\n * Don't add values to these!!\n */\nconst EMPTY_OBJ = {};\n/**\n * Namespaces\n */\nconst SVG_NS = 'http://www.w3.org/2000/svg';\nconst HTML_NS = 'http://www.w3.org/1999/xhtml';\nconst isDef = (v) => v != null;\nconst isComplexType = (o) => {\n    // https://jsperf.com/typeof-fn-object/5\n    o = typeof o;\n    return o === 'object' || o === 'function';\n};\nconst getDynamicImportFunction = (namespace) => `__sc_import_${namespace.replace(/\\s|-/g, '_')}`;\nconst patchEsm = () => {\n    // @ts-ignore\n    if ( !(CSS && CSS.supports && CSS.supports('color', 'var(--c)'))) {\n        // @ts-ignore\n        return import(/* webpackChunkName: \"stencil-polyfills-css-shim\" */ './css-shim-8775d9ad-556f0cc2.js').then(() => {\n            if (plt.$cssShim$ = win.__cssshim) {\n                return plt.$cssShim$.i();\n            }\n            else {\n                // for better minification\n                return 0;\n            }\n        });\n    }\n    return promiseResolve();\n};\nconst patchBrowser = () => {\n    {\n        // shim css vars\n        plt.$cssShim$ = win.__cssshim;\n    }\n    // @ts-ignore\n    const scriptElm = \n        Array.from(doc.querySelectorAll('script')).find(s => (new RegExp(`\\/${NAMESPACE}(\\\\.esm)?\\\\.js($|\\\\?|#)`).test(s.src) ||\n            s.getAttribute('data-stencil-namespace') === NAMESPACE)) ;\n    const opts =  {};\n    if ( 'onbeforeload' in scriptElm && !history.scrollRestoration /* IS_ESM_BUILD */) {\n        // Safari < v11 support: This IF is true if it's Safari below v11.\n        // This fn cannot use async/await since Safari didn't support it until v11,\n        // however, Safari 10 did support modules. Safari 10 also didn't support \"nomodule\",\n        // so both the ESM file and nomodule file would get downloaded. Only Safari\n        // has 'onbeforeload' in the script, and \"history.scrollRestoration\" was added\n        // to Safari in v11. Return a noop then() so the async/await ESM code doesn't continue.\n        // IS_ESM_BUILD is replaced at build time so this check doesn't happen in systemjs builds.\n        return { then() { } };\n    }\n    {\n        opts.resourcesUrl = new URL('.', new URL(scriptElm.getAttribute('data-resources-url') || scriptElm.src, win.location.href)).href;\n        patchDynamicImport(opts.resourcesUrl, scriptElm);\n        if ( !win.customElements) {\n            // module support, but no custom elements support (Old Edge)\n            // @ts-ignore\n            return import(/* webpackChunkName: \"stencil-polyfills-dom\" */ './dom-76cc7c7d-0a082895.js').then(() => opts);\n        }\n    }\n    return promiseResolve(opts);\n};\nconst patchDynamicImport = (base, orgScriptElm) => {\n    const importFunctionName = getDynamicImportFunction(NAMESPACE);\n    try {\n        // test if this browser supports dynamic imports\n        // There is a caching issue in V8, that breaks using import() in Function\n        // By generating a random string, we can workaround it\n        // Check https://bugs.chromium.org/p/v8/issues/detail?id=9558 for more info\n        win[importFunctionName] = new Function('w', `return import(w);//${Math.random()}`);\n    }\n    catch (e) {\n        // this shim is specifically for browsers that do support \"esm\" imports\n        // however, they do NOT support \"dynamic\" imports\n        // basically this code is for old Edge, v18 and below\n        const moduleMap = new Map();\n        win[importFunctionName] = (src) => {\n            const url = new URL(src, base).href;\n            let mod = moduleMap.get(url);\n            if (!mod) {\n                const script = doc.createElement('script');\n                script.type = 'module';\n                script.crossOrigin = orgScriptElm.crossOrigin;\n                script.src = URL.createObjectURL(new Blob([`import * as m from '${url}'; window.${importFunctionName}.m = m;`], { type: 'application/javascript' }));\n                mod = new Promise(resolve => {\n                    script.onload = () => {\n                        resolve(win[importFunctionName].m);\n                        script.remove();\n                    };\n                });\n                moduleMap.set(url, mod);\n                doc.head.appendChild(script);\n            }\n            return mod;\n        };\n    }\n};\nconst HYDRATED_CSS = '{visibility:hidden}.hydrated{visibility:inherit}';\nconst createTime = (fnName, tagName = '') => {\n    {\n        return () => { return; };\n    }\n};\nconst uniqueTime = (key, measureText) => {\n    {\n        return () => { return; };\n    }\n};\nconst rootAppliedStyles = new WeakMap();\nconst registerStyle = (scopeId, cssText, allowCS) => {\n    let style = styles.get(scopeId);\n    if (supportsConstructibleStylesheets && allowCS) {\n        style = (style || new CSSStyleSheet());\n        style.replace(cssText);\n    }\n    else {\n        style = cssText;\n    }\n    styles.set(scopeId, style);\n};\nconst addStyle = (styleContainerNode, cmpMeta, mode, hostElm) => {\n    let scopeId =  getScopeId(cmpMeta.$tagName$);\n    let style = styles.get(scopeId);\n    // if an element is NOT connected then getRootNode() will return the wrong root node\n    // so the fallback is to always use the document for the root node in those cases\n    styleContainerNode = (styleContainerNode.nodeType === 11 /* DocumentFragment */ ? styleContainerNode : doc);\n    if (style) {\n        if (typeof style === 'string') {\n            styleContainerNode = styleContainerNode.head || styleContainerNode;\n            let appliedStyles = rootAppliedStyles.get(styleContainerNode);\n            let styleElm;\n            if (!appliedStyles) {\n                rootAppliedStyles.set(styleContainerNode, appliedStyles = new Set());\n            }\n            if (!appliedStyles.has(scopeId)) {\n                {\n                    if ( plt.$cssShim$) {\n                        styleElm = plt.$cssShim$.createHostStyle(hostElm, scopeId, style, !!(cmpMeta.$flags$ & 10 /* needsScopedEncapsulation */));\n                        const newScopeId = styleElm['s-sc'];\n                        if (newScopeId) {\n                            scopeId = newScopeId;\n                            // we don't want to add this styleID to the appliedStyles Set\n                            // since the cssVarShim might need to apply several different\n                            // stylesheets for the same component\n                            appliedStyles = null;\n                        }\n                    }\n                    else {\n                        styleElm = doc.createElement('style');\n                        styleElm.innerHTML = style;\n                    }\n                    styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector('link'));\n                }\n                if (appliedStyles) {\n                    appliedStyles.add(scopeId);\n                }\n            }\n        }\n        else if ( !styleContainerNode.adoptedStyleSheets.includes(style)) {\n            styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];\n        }\n    }\n    return scopeId;\n};\nconst attachStyles = (elm, cmpMeta, mode) => {\n    const endAttachStyles = createTime('attachStyles', cmpMeta.$tagName$);\n    const scopeId = addStyle(( supportsShadowDom && elm.shadowRoot)\n        ? elm.shadowRoot\n        : elm.getRootNode(), cmpMeta, mode, elm);\n    if ( cmpMeta.$flags$ & 10 /* needsScopedEncapsulation */) {\n        // only required when we're NOT using native shadow dom (slot)\n        // or this browser doesn't support native shadow dom\n        // and this host element was NOT created with SSR\n        // let's pick out the inner content for slot projection\n        // create a node to represent where the original\n        // content was first placed, which is useful later on\n        // DOM WRITE!!\n        elm['s-sc'] = scopeId;\n        elm.classList.add(scopeId + '-h');\n    }\n    endAttachStyles();\n};\nconst getScopeId = (tagName, mode) => 'sc-' + ( tagName);\n/**\n * Production h() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\n// const stack: any[] = [];\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;\nconst h = (nodeName, vnodeData, ...children) => {\n    let child = null;\n    let simple = false;\n    let lastSimple = false;\n    let vNodeChildren = [];\n    const walk = (c) => {\n        for (let i = 0; i < c.length; i++) {\n            child = c[i];\n            if (Array.isArray(child)) {\n                walk(child);\n            }\n            else if (child != null && typeof child !== 'boolean') {\n                if (simple = typeof nodeName !== 'function' && !isComplexType(child)) {\n                    child = String(child);\n                }\n                if (simple && lastSimple) {\n                    // If the previous child was simple (string), we merge both\n                    vNodeChildren[vNodeChildren.length - 1].$text$ += child;\n                }\n                else {\n                    // Append a new vNode, if it's text, we create a text vNode\n                    vNodeChildren.push(simple ? newVNode(null, child) : child);\n                }\n                lastSimple = simple;\n            }\n        }\n    };\n    walk(children);\n    if (vnodeData) {\n        {\n            const classData = vnodeData.className || vnodeData.class;\n            if (classData) {\n                vnodeData.class = typeof classData !== 'object'\n                    ? classData\n                    : Object.keys(classData)\n                        .filter(k => classData[k])\n                        .join(' ');\n            }\n        }\n    }\n    const vnode = newVNode(nodeName, null);\n    vnode.$attrs$ = vnodeData;\n    if (vNodeChildren.length > 0) {\n        vnode.$children$ = vNodeChildren;\n    }\n    return vnode;\n};\nconst newVNode = (tag, text) => {\n    const vnode = {\n        $flags$: 0,\n        $tag$: tag,\n        $text$: text,\n        $elm$: null,\n        $children$: null\n    };\n    {\n        vnode.$attrs$ = null;\n    }\n    return vnode;\n};\nconst Host = {};\nconst isHost = (node) => node && node.$tag$ === Host;\n/**\n * Production setAccessor() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\nconst setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {\n    if (oldValue !== newValue) {\n        let isProp = isMemberInElement(elm, memberName);\n        let ln = memberName.toLowerCase();\n        if ( memberName === 'class') {\n            const classList = elm.classList;\n            const oldClasses = parseClassList(oldValue);\n            const newClasses = parseClassList(newValue);\n            classList.remove(...oldClasses.filter(c => c && !newClasses.includes(c)));\n            classList.add(...newClasses.filter(c => c && !oldClasses.includes(c)));\n        }\n        else if ( memberName === 'style') {\n            // update style attribute, css properties and values\n            {\n                for (const prop in oldValue) {\n                    if (!newValue || newValue[prop] == null) {\n                        if ( prop.includes('-')) {\n                            elm.style.removeProperty(prop);\n                        }\n                        else {\n                            elm.style[prop] = '';\n                        }\n                    }\n                }\n            }\n            for (const prop in newValue) {\n                if (!oldValue || newValue[prop] !== oldValue[prop]) {\n                    if ( prop.includes('-')) {\n                        elm.style.setProperty(prop, newValue[prop]);\n                    }\n                    else {\n                        elm.style[prop] = newValue[prop];\n                    }\n                }\n            }\n        }\n        else if ( memberName === 'ref') {\n            // minifier will clean this up\n            if (newValue) {\n                newValue(elm);\n            }\n        }\n        else if (\n            ( !isProp\n                ) &&\n            memberName[0] === 'o' && memberName[1] === 'n') {\n            // Event Handlers\n            // so if the member name starts with \"on\" and the 3rd characters is\n            // a capital letter, and it's not already a member on the element,\n            // then we're assuming it's an event listener\n            if (memberName[2] === '-') {\n                // on- prefixed events\n                // allows to be explicit about the dom event to listen without any magic\n                // under the hood:\n                // <my-cmp on-click> // listens for \"click\"\n                // <my-cmp on-Click> // listens for \"Click\"\n                // <my-cmp on-ionChange> // listens for \"ionChange\"\n                // <my-cmp on-EVENTS> // listens for \"EVENTS\"\n                memberName = memberName.slice(3);\n            }\n            else if (isMemberInElement(win, ln)) {\n                // standard event\n                // the JSX attribute could have been \"onMouseOver\" and the\n                // member name \"onmouseover\" is on the window's prototype\n                // so let's add the listener \"mouseover\", which is all lowercased\n                memberName = ln.slice(2);\n            }\n            else {\n                // custom event\n                // the JSX attribute could have been \"onMyCustomEvent\"\n                // so let's trim off the \"on\" prefix and lowercase the first character\n                // and add the listener \"myCustomEvent\"\n                // except for the first character, we keep the event name case\n                memberName = ln[2] + memberName.slice(3);\n            }\n            if (oldValue) {\n                plt.rel(elm, memberName, oldValue, false);\n            }\n            if (newValue) {\n                plt.ael(elm, memberName, newValue, false);\n            }\n        }\n        else {\n            // Set property if it exists and it's not a SVG\n            const isComplex = isComplexType(newValue);\n            if ((isProp || (isComplex && newValue !== null)) && !isSvg) {\n                try {\n                    if (!elm.tagName.includes('-')) {\n                        let n = newValue == null ? '' : newValue;\n                        // Workaround for Safari, moving the <input> caret when re-assigning the same valued\n                        if (memberName === 'list') {\n                            isProp = false;\n                            // tslint:disable-next-line: triple-equals\n                        }\n                        else if (oldValue == null || elm[memberName] != n) {\n                            elm[memberName] = n;\n                        }\n                    }\n                    else {\n                        elm[memberName] = newValue;\n                    }\n                }\n                catch (e) { }\n            }\n            if (newValue == null || newValue === false) {\n                {\n                    elm.removeAttribute(memberName);\n                }\n            }\n            else if ((!isProp || (flags & 4 /* isHost */) || isSvg) && !isComplex) {\n                newValue = newValue === true ? '' : newValue;\n                {\n                    elm.setAttribute(memberName, newValue);\n                }\n            }\n        }\n    }\n};\nconst parseClassListRegex = /\\s/;\nconst parseClassList = (value) => (!value) ? [] : value.split(parseClassListRegex);\nconst updateElement = (oldVnode, newVnode, isSvgMode, memberName) => {\n    // if the element passed in is a shadow root, which is a document fragment\n    // then we want to be adding attrs/props to the shadow root's \"host\" element\n    // if it's not a shadow root, then we add attrs/props to the same element\n    const elm = (newVnode.$elm$.nodeType === 11 /* DocumentFragment */ && newVnode.$elm$.host) ? newVnode.$elm$.host : newVnode.$elm$;\n    const oldVnodeAttrs = (oldVnode && oldVnode.$attrs$) || EMPTY_OBJ;\n    const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;\n    {\n        // remove attributes no longer present on the vnode by setting them to undefined\n        for (memberName in oldVnodeAttrs) {\n            if (!(memberName in newVnodeAttrs)) {\n                setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);\n            }\n        }\n    }\n    // add new & update changed attributes\n    for (memberName in newVnodeAttrs) {\n        setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);\n    }\n};\nconst createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {\n    // tslint:disable-next-line: prefer-const\n    let newVNode = newParentVNode.$children$[childIndex];\n    let i = 0;\n    let elm;\n    let childNode;\n    if ( newVNode.$text$ !== null) {\n        // create text node\n        elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);\n    }\n    else {\n        if ( !isSvgMode) {\n            isSvgMode = newVNode.$tag$ === 'svg';\n        }\n        // create element\n        elm = newVNode.$elm$ = ( doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS,  newVNode.$tag$)\n            );\n        if ( isSvgMode && newVNode.$tag$ === 'foreignObject') {\n            isSvgMode = false;\n        }\n        // add css classes, attrs, props, listeners, etc.\n        {\n            updateElement(null, newVNode, isSvgMode);\n        }\n        if ( isDef(scopeId) && elm['s-si'] !== scopeId) {\n            // if there is a scopeId and this is the initial render\n            // then let's add the scopeId as a css class\n            elm.classList.add((elm['s-si'] = scopeId));\n        }\n        if (newVNode.$children$) {\n            for (i = 0; i < newVNode.$children$.length; ++i) {\n                // create the node\n                childNode = createElm(oldParentVNode, newVNode, i);\n                // return node could have been null\n                if (childNode) {\n                    // append our new node\n                    elm.appendChild(childNode);\n                }\n            }\n        }\n        {\n            if (newVNode.$tag$ === 'svg') {\n                // Only reset the SVG context when we're exiting <svg> element\n                isSvgMode = false;\n            }\n            else if (elm.tagName === 'foreignObject') {\n                // Reenter SVG context when we're exiting <foreignObject> element\n                isSvgMode = true;\n            }\n        }\n    }\n    return elm;\n};\nconst addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {\n    let containerElm = ( parentElm);\n    let childNode;\n    if ( containerElm.shadowRoot && containerElm.tagName === hostTagName) {\n        containerElm = containerElm.shadowRoot;\n    }\n    for (; startIdx <= endIdx; ++startIdx) {\n        if (vnodes[startIdx]) {\n            childNode = createElm(null, parentVNode, startIdx);\n            if (childNode) {\n                vnodes[startIdx].$elm$ = childNode;\n                containerElm.insertBefore(childNode,  before);\n            }\n        }\n    }\n};\nconst removeVnodes = (vnodes, startIdx, endIdx, vnode, elm) => {\n    for (; startIdx <= endIdx; ++startIdx) {\n        if (vnode = vnodes[startIdx]) {\n            elm = vnode.$elm$;\n            callNodeRefs(vnode);\n            // remove the vnode's element from the dom\n            elm.remove();\n        }\n    }\n};\nconst updateChildren = (parentElm, oldCh, newVNode, newCh) => {\n    let oldStartIdx = 0;\n    let newStartIdx = 0;\n    let oldEndIdx = oldCh.length - 1;\n    let oldStartVnode = oldCh[0];\n    let oldEndVnode = oldCh[oldEndIdx];\n    let newEndIdx = newCh.length - 1;\n    let newStartVnode = newCh[0];\n    let newEndVnode = newCh[newEndIdx];\n    let node;\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (oldStartVnode == null) {\n            // Vnode might have been moved left\n            oldStartVnode = oldCh[++oldStartIdx];\n        }\n        else if (oldEndVnode == null) {\n            oldEndVnode = oldCh[--oldEndIdx];\n        }\n        else if (newStartVnode == null) {\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (newEndVnode == null) {\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldStartVnode, newStartVnode)) {\n            patch(oldStartVnode, newStartVnode);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (isSameVnode(oldEndVnode, newEndVnode)) {\n            patch(oldEndVnode, newEndVnode);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldStartVnode, newEndVnode)) {\n            patch(oldStartVnode, newEndVnode);\n            parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldEndVnode, newStartVnode)) {\n            patch(oldEndVnode, newStartVnode);\n            parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else {\n            {\n                // new element\n                node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx);\n                newStartVnode = newCh[++newStartIdx];\n            }\n            if (node) {\n                {\n                    oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);\n                }\n            }\n        }\n    }\n    if (oldStartIdx > oldEndIdx) {\n        addVnodes(parentElm, (newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$), newVNode, newCh, newStartIdx, newEndIdx);\n    }\n    else if ( newStartIdx > newEndIdx) {\n        removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n    }\n};\nconst isSameVnode = (vnode1, vnode2) => {\n    // compare if two vnode to see if they're \"technically\" the same\n    // need to have the same element tag, and same key to be the same\n    if (vnode1.$tag$ === vnode2.$tag$) {\n        return true;\n    }\n    return false;\n};\nconst patch = (oldVNode, newVNode) => {\n    const elm = newVNode.$elm$ = oldVNode.$elm$;\n    const oldChildren = oldVNode.$children$;\n    const newChildren = newVNode.$children$;\n    const tag = newVNode.$tag$;\n    const text = newVNode.$text$;\n    if ( text === null) {\n        {\n            // test if we're rendering an svg element, or still rendering nodes inside of one\n            // only add this to the when the compiler sees we're using an svg somewhere\n            isSvgMode = (tag === 'svg')\n                ? true\n                : (tag === 'foreignObject')\n                    ? false\n                    : isSvgMode;\n        }\n        // element node\n        {\n            {\n                // either this is the first render of an element OR it's an update\n                // AND we already know it's possible it could have changed\n                // this updates the element's css classes, attrs, props, listeners, etc.\n                updateElement(oldVNode, newVNode, isSvgMode);\n            }\n        }\n        if ( oldChildren !== null && newChildren !== null) {\n            // looks like there's child vnodes for both the old and new vnodes\n            updateChildren(elm, oldChildren, newVNode, newChildren);\n        }\n        else if (newChildren !== null) {\n            // no old child vnodes, but there are new child vnodes to add\n            if ( oldVNode.$text$ !== null) {\n                // the old vnode was text, so be sure to clear it out\n                elm.textContent = '';\n            }\n            // add the new vnode children\n            addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);\n        }\n        else if ( oldChildren !== null) {\n            // no new child vnodes, but there are old child vnodes to remove\n            removeVnodes(oldChildren, 0, oldChildren.length - 1);\n        }\n        if ( isSvgMode && tag === 'svg') {\n            isSvgMode = false;\n        }\n    }\n    else if ( oldVNode.$text$ !== text) {\n        // update the text content for the text only vnode\n        // and also only if the text is different than before\n        elm.data = text;\n    }\n};\nconst callNodeRefs = (vNode) => {\n    {\n        vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);\n        vNode.$children$ && vNode.$children$.forEach(callNodeRefs);\n    }\n};\nconst renderVdom = (hostElm, hostRef, cmpMeta, renderFnResults) => {\n    hostTagName = hostElm.tagName;\n    const oldVNode = hostRef.$vnode$ || newVNode(null, null);\n    const rootVnode = isHost(renderFnResults)\n        ? renderFnResults\n        : h(null, null, renderFnResults);\n    rootVnode.$tag$ = null;\n    rootVnode.$flags$ |= 4 /* isHost */;\n    hostRef.$vnode$ = rootVnode;\n    rootVnode.$elm$ = oldVNode.$elm$ = ( hostElm.shadowRoot || hostElm );\n    {\n        scopeId = hostElm['s-sc'];\n    }\n    // synchronous patch\n    patch(oldVNode, rootVnode);\n};\nconst attachToAncestor = (hostRef, ancestorComponent) => {\n    if ( ancestorComponent && !hostRef.$onRenderResolve$) {\n        ancestorComponent['s-p'].push(new Promise(r => hostRef.$onRenderResolve$ = r));\n    }\n};\nconst scheduleUpdate = (elm, hostRef, cmpMeta, isInitialLoad) => {\n    {\n        hostRef.$flags$ |= 16 /* isQueuedForUpdate */;\n    }\n    if ( hostRef.$flags$ & 4 /* isWaitingForChildren */) {\n        hostRef.$flags$ |= 512 /* needsRerender */;\n        return;\n    }\n    const endSchedule = createTime('scheduleUpdate', cmpMeta.$tagName$);\n    const ancestorComponent = hostRef.$ancestorComponent$;\n    const instance =  hostRef.$lazyInstance$ ;\n    const update = () => updateComponent(elm, hostRef, cmpMeta, instance, isInitialLoad);\n    attachToAncestor(hostRef, ancestorComponent);\n    let promise;\n    if (isInitialLoad) {\n        {\n            hostRef.$flags$ |= 256 /* isListenReady */;\n            if (hostRef.$queuedListeners$) {\n                hostRef.$queuedListeners$.forEach(([methodName, event]) => safeCall(instance, methodName, event));\n                hostRef.$queuedListeners$ = null;\n            }\n        }\n    }\n    endSchedule();\n    // there is no ancestorc omponent or the ancestor component\n    // has already fired off its lifecycle update then\n    // fire off the initial update\n    return then(promise,  () => writeTask(update)\n        );\n};\nconst updateComponent = (elm, hostRef, cmpMeta, instance, isInitialLoad) => {\n    // updateComponent\n    const endUpdate = createTime('update', cmpMeta.$tagName$);\n    const rc = elm['s-rc'];\n    if ( isInitialLoad) {\n        // DOM WRITE!\n        attachStyles(elm, cmpMeta, hostRef.$modeName$);\n    }\n    const endRender = createTime('render', cmpMeta.$tagName$);\n    {\n        {\n            // looks like we've got child nodes to render into this host element\n            // or we need to update the css class/attrs on the host element\n            // DOM WRITE!\n            renderVdom(elm, hostRef, cmpMeta, callRender(instance));\n        }\n    }\n    if ( plt.$cssShim$) {\n        plt.$cssShim$.updateHost(elm);\n    }\n    {\n        hostRef.$flags$ &= ~16 /* isQueuedForUpdate */;\n    }\n    {\n        hostRef.$flags$ |= 2 /* hasRendered */;\n    }\n    if ( rc) {\n        // ok, so turns out there are some child host elements\n        // waiting on this parent element to load\n        // let's fire off all update callbacks waiting\n        rc.forEach(cb => cb());\n        elm['s-rc'] = undefined;\n    }\n    endRender();\n    endUpdate();\n    {\n        const childrenPromises = elm['s-p'];\n        const postUpdate = () => postUpdateComponent(elm, hostRef, cmpMeta);\n        if (childrenPromises.length === 0) {\n            postUpdate();\n        }\n        else {\n            Promise.all(childrenPromises).then(postUpdate);\n            hostRef.$flags$ |= 4 /* isWaitingForChildren */;\n            childrenPromises.length = 0;\n        }\n    }\n};\nconst callRender = (instance, elm) => {\n    try {\n        instance =  instance.render() ;\n    }\n    catch (e) {\n        consoleError(e);\n    }\n    return instance;\n};\nconst postUpdateComponent = (elm, hostRef, cmpMeta) => {\n    const endPostUpdate = createTime('postUpdate', cmpMeta.$tagName$);\n    const instance =  hostRef.$lazyInstance$ ;\n    const ancestorComponent = hostRef.$ancestorComponent$;\n    if (!(hostRef.$flags$ & 64 /* hasLoadedComponent */)) {\n        hostRef.$flags$ |= 64 /* hasLoadedComponent */;\n        {\n            // DOM WRITE!\n            addHydratedFlag(elm);\n        }\n        {\n            safeCall(instance, 'componentDidLoad');\n        }\n        endPostUpdate();\n        {\n            hostRef.$onReadyResolve$(elm);\n            if (!ancestorComponent) {\n                appDidLoad();\n            }\n        }\n    }\n    else {\n        endPostUpdate();\n    }\n    {\n        hostRef.$onInstanceResolve$(elm);\n    }\n    // load events fire from bottom to top\n    // the deepest elements load first then bubbles up\n    {\n        if (hostRef.$onRenderResolve$) {\n            hostRef.$onRenderResolve$();\n            hostRef.$onRenderResolve$ = undefined;\n        }\n        if (hostRef.$flags$ & 512 /* needsRerender */) {\n            nextTick(() => scheduleUpdate(elm, hostRef, cmpMeta, false));\n        }\n        hostRef.$flags$ &= ~(4 /* isWaitingForChildren */ | 512 /* needsRerender */);\n    }\n    // ( •_•)\n    // ( •_•)>⌐■-■\n    // (⌐■_■)\n};\nconst forceUpdate = (elm, cmpMeta) => {\n    {\n        const hostRef = getHostRef(elm);\n        const isConnected = hostRef.$hostElement$.isConnected;\n        if (isConnected && (hostRef.$flags$ & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\n            scheduleUpdate(elm, hostRef, cmpMeta, false);\n        }\n        // Returns \"true\" when the forced update was successfully scheduled\n        return isConnected;\n    }\n};\nconst appDidLoad = (who) => {\n    // on appload\n    // we have finish the first big initial render\n    {\n        addHydratedFlag(doc.documentElement);\n    }\n    {\n        plt.$flags$ |= 2 /* appLoaded */;\n    }\n};\nconst safeCall = (instance, method, arg) => {\n    if (instance && instance[method]) {\n        try {\n            return instance[method](arg);\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    return undefined;\n};\nconst then = (promise, thenFn) => {\n    return promise && promise.then ? promise.then(thenFn) : thenFn();\n};\nconst addHydratedFlag = (elm) => \n    elm.classList.add('hydrated') ;\nconst addEventListeners = (elm, hostRef, listeners) => {\n    hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || [];\n    const removeFns = listeners.map(([flags, name, method]) => {\n        const target = ( getHostListenerTarget(elm, flags) );\n        const handler = hostListenerProxy(hostRef, method);\n        const opts = hostListenerOpts(flags);\n        plt.ael(target, name, handler, opts);\n        return () => plt.rel(target, name, handler, opts);\n    });\n    return () => removeFns.forEach(fn => fn());\n};\nconst hostListenerProxy = (hostRef, methodName) => {\n    return (ev) => {\n        {\n            if (hostRef.$flags$ & 256 /* isListenReady */) {\n                // instance is ready, let's call it's member method for this event\n                hostRef.$lazyInstance$[methodName](ev);\n            }\n            else {\n                hostRef.$queuedListeners$.push([methodName, ev]);\n            }\n        }\n    };\n};\nconst getHostListenerTarget = (elm, flags) => {\n    if ( flags & 32 /* TargetBody */)\n        return doc.body;\n    return elm;\n};\nconst hostListenerOpts = (flags) =>  (flags & 2 /* Capture */) !== 0;\nconst parsePropertyValue = (propValue, propType) => {\n    // ensure this value is of the correct prop type\n    if (propValue != null && !isComplexType(propValue)) {\n        if ( propType & 4 /* Boolean */) {\n            // per the HTML spec, any string value means it is a boolean true value\n            // but we'll cheat here and say that the string \"false\" is the boolean false\n            return (propValue === 'false' ? false : propValue === '' || !!propValue);\n        }\n        if ( propType & 2 /* Number */) {\n            // force it to be a number\n            return parseFloat(propValue);\n        }\n        if ( propType & 1 /* String */) {\n            // could have been passed as a number or boolean\n            // but we still want it as a string\n            return String(propValue);\n        }\n        // redundant return here for better minification\n        return propValue;\n    }\n    // not sure exactly what type we want\n    // so no need to change to a different type\n    return propValue;\n};\nconst getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);\nconst setValue = (ref, propName, newVal, cmpMeta) => {\n    // check our new property value against our internal value\n    const hostRef = getHostRef(ref);\n    const elm =  hostRef.$hostElement$ ;\n    const oldVal = hostRef.$instanceValues$.get(propName);\n    const flags = hostRef.$flags$;\n    const instance =  hostRef.$lazyInstance$ ;\n    newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);\n    if (newVal !== oldVal && ( !(flags & 8 /* isConstructingInstance */) || oldVal === undefined)) {\n        // gadzooks! the property's value has changed!!\n        // set our new value!\n        hostRef.$instanceValues$.set(propName, newVal);\n        if ( instance) {\n            if ( (flags & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\n                // looks like this value actually changed, so we've got work to do!\n                // but only if we've already rendered, otherwise just chill out\n                // queue that we need to do an update, but don't worry about queuing\n                // up millions cuz this function ensures it only runs once\n                scheduleUpdate(elm, hostRef, cmpMeta, false);\n            }\n        }\n    }\n};\nconst proxyComponent = (Cstr, cmpMeta, flags) => {\n    if ( cmpMeta.$members$) {\n        // It's better to have a const than two Object.entries()\n        const members = Object.entries(cmpMeta.$members$);\n        const prototype = Cstr.prototype;\n        members.forEach(([memberName, [memberFlags]]) => {\n            if ( ((memberFlags & 31 /* Prop */) ||\n                (( flags & 2 /* proxyState */) &&\n                    (memberFlags & 32 /* State */)))) {\n                // proxyComponent - prop\n                Object.defineProperty(prototype, memberName, {\n                    get() {\n                        // proxyComponent, get value\n                        return getValue(this, memberName);\n                    },\n                    set(newValue) {\n                        // proxyComponent, set value\n                        setValue(this, memberName, newValue, cmpMeta);\n                    },\n                    configurable: true,\n                    enumerable: true\n                });\n            }\n            else if ( (flags & 1 /* isElementConstructor */) && (memberFlags & 64 /* Method */)) {\n                // proxyComponent - method\n                Object.defineProperty(prototype, memberName, {\n                    value(...args) {\n                        const ref = getHostRef(this);\n                        return ref.$onInstancePromise$.then(() => ref.$lazyInstance$[memberName](...args));\n                    }\n                });\n            }\n        });\n        if ( ( flags & 1 /* isElementConstructor */)) {\n            const attrNameToPropName = new Map();\n            prototype.attributeChangedCallback = function (attrName, _oldValue, newValue) {\n                plt.jmp(() => {\n                    const propName = attrNameToPropName.get(attrName);\n                    this[propName] = newValue === null && typeof this[propName] === 'boolean'\n                        ? false\n                        : newValue;\n                });\n            };\n            // create an array of attributes to observe\n            // and also create a map of html attribute name to js property name\n            Cstr.observedAttributes = members\n                .filter(([_, m]) => m[0] & 15 /* HasAttribute */) // filter to only keep props that should match attributes\n                .map(([propName, m]) => {\n                const attrName = m[1] || propName;\n                attrNameToPropName.set(attrName, propName);\n                return attrName;\n            });\n        }\n    }\n    return Cstr;\n};\nconst initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId, Cstr) => {\n    // initializeComponent\n    if ( (hostRef.$flags$ & 32 /* hasInitializedComponent */) === 0) {\n        // we haven't initialized this element yet\n        hostRef.$flags$ |= 32 /* hasInitializedComponent */;\n        {\n            // lazy loaded components\n            // request the component's implementation to be\n            // wired up with the host element\n            Cstr = loadModule(cmpMeta);\n            if (Cstr.then) {\n                // Await creates a micro-task avoid if possible\n                const endLoad = uniqueTime();\n                Cstr = await Cstr;\n                endLoad();\n            }\n            if ( !Cstr.isProxied) {\n                proxyComponent(Cstr, cmpMeta, 2 /* proxyState */);\n                Cstr.isProxied = true;\n            }\n            const endNewInstance = createTime('createInstance', cmpMeta.$tagName$);\n            // ok, time to construct the instance\n            // but let's keep track of when we start and stop\n            // so that the getters/setters don't incorrectly step on data\n            {\n                hostRef.$flags$ |= 8 /* isConstructingInstance */;\n            }\n            // construct the lazy-loaded component implementation\n            // passing the hostRef is very important during\n            // construction in order to directly wire together the\n            // host element and the lazy-loaded instance\n            try {\n                new Cstr(hostRef);\n            }\n            catch (e) {\n                consoleError(e);\n            }\n            {\n                hostRef.$flags$ &= ~8 /* isConstructingInstance */;\n            }\n            endNewInstance();\n        }\n        const scopeId =  getScopeId(cmpMeta.$tagName$);\n        if ( !styles.has(scopeId) && Cstr.style) {\n            const endRegisterStyles = createTime('registerStyles', cmpMeta.$tagName$);\n            // this component has styles but we haven't registered them yet\n            let style = Cstr.style;\n            if ( cmpMeta.$flags$ & 8 /* needsShadowDomShim */) {\n                style = await import('./shadow-css-d7d058ec-d59cb009.js').then(m => m.scopeCss(style, scopeId, false));\n            }\n            registerStyle(scopeId, style, !!(cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */));\n            endRegisterStyles();\n        }\n    }\n    // we've successfully created a lazy instance\n    const ancestorComponent = hostRef.$ancestorComponent$;\n    const schedule = () => scheduleUpdate(elm, hostRef, cmpMeta, true);\n    if ( ancestorComponent && ancestorComponent['s-rc']) {\n        // this is the intial load and this component it has an ancestor component\n        // but the ancestor component has NOT fired its will update lifecycle yet\n        // so let's just cool our jets and wait for the ancestor to continue first\n        // this will get fired off when the ancestor component\n        // finally gets around to rendering its lazy self\n        // fire off the initial update\n        ancestorComponent['s-rc'].push(schedule);\n    }\n    else {\n        schedule();\n    }\n};\nconst connectedCallback = (elm, cmpMeta) => {\n    if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n        const endConnected = createTime('connectedCallback', cmpMeta.$tagName$);\n        // connectedCallback\n        const hostRef = getHostRef(elm);\n        if ( cmpMeta.$listeners$) {\n            // initialize our event listeners on the host element\n            // we do this now so that we can listening to events that may\n            // have fired even before the instance is ready\n            hostRef.$rmListeners$ = addEventListeners(elm, hostRef, cmpMeta.$listeners$);\n        }\n        if (!(hostRef.$flags$ & 1 /* hasConnected */)) {\n            // first time this component has connected\n            hostRef.$flags$ |= 1 /* hasConnected */;\n            {\n                // find the first ancestor component (if there is one) and register\n                // this component as one of the actively loading child components for its ancestor\n                let ancestorComponent = elm;\n                while ((ancestorComponent = (ancestorComponent.parentNode || ancestorComponent.host))) {\n                    // climb up the ancestors looking for the first\n                    // component that hasn't finished its lifecycle update yet\n                    if (\n                        (ancestorComponent['s-p'])) {\n                        // we found this components first ancestor component\n                        // keep a reference to this component's ancestor component\n                        attachToAncestor(hostRef, (hostRef.$ancestorComponent$ = ancestorComponent));\n                        break;\n                    }\n                }\n            }\n            // Lazy properties\n            // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n            if ( cmpMeta.$members$) {\n                Object.entries(cmpMeta.$members$).forEach(([memberName, [memberFlags]]) => {\n                    if (memberFlags & 31 /* Prop */ && elm.hasOwnProperty(memberName)) {\n                        const value = elm[memberName];\n                        delete elm[memberName];\n                        elm[memberName] = value;\n                    }\n                });\n            }\n            {\n                // connectedCallback, taskQueue, initialLoad\n                // angular sets attribute AFTER connectCallback\n                // https://github.com/angular/angular/issues/18909\n                // https://github.com/angular/angular/issues/19940\n                nextTick(() => initializeComponent(elm, hostRef, cmpMeta));\n            }\n        }\n        endConnected();\n    }\n};\nconst disconnectedCallback = (elm) => {\n    if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n        const hostRef = getHostRef(elm);\n        const instance =  hostRef.$lazyInstance$ ;\n        {\n            if (hostRef.$rmListeners$) {\n                hostRef.$rmListeners$();\n                hostRef.$rmListeners$ = undefined;\n            }\n        }\n        // clear CSS var-shim tracking\n        if ( plt.$cssShim$) {\n            plt.$cssShim$.removeHost(elm);\n        }\n        {\n            safeCall(instance, 'componentDidUnload');\n        }\n    }\n};\nconst bootstrapLazy = (lazyBundles, options = {}) => {\n    const endBootstrap = createTime();\n    const cmpTags = [];\n    const exclude = options.exclude || [];\n    const customElements = win.customElements;\n    const head = doc.head;\n    const metaCharset = /*@__PURE__*/ head.querySelector('meta[charset]');\n    const visibilityStyle = /*@__PURE__*/ doc.createElement('style');\n    const deferredConnectedCallbacks = [];\n    let appLoadFallback;\n    let isBootstrapping = true;\n    Object.assign(plt, options);\n    plt.$resourcesUrl$ = new URL(options.resourcesUrl || './', doc.baseURI).href;\n    if (options.syncQueue) {\n        plt.$flags$ |= 4 /* queueSync */;\n    }\n    lazyBundles.forEach(lazyBundle => lazyBundle[1].forEach(compactMeta => {\n        const cmpMeta = {\n            $flags$: compactMeta[0],\n            $tagName$: compactMeta[1],\n            $members$: compactMeta[2],\n            $listeners$: compactMeta[3],\n        };\n        {\n            cmpMeta.$members$ = compactMeta[2];\n        }\n        {\n            cmpMeta.$listeners$ = compactMeta[3];\n        }\n        if ( !supportsShadowDom && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n            cmpMeta.$flags$ |= 8 /* needsShadowDomShim */;\n        }\n        const tagName = cmpMeta.$tagName$;\n        const HostElement = class extends HTMLElement {\n            // StencilLazyHost\n            constructor(self) {\n                // @ts-ignore\n                super(self);\n                self = this;\n                registerHost(self);\n                if ( cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n                    // this component is using shadow dom\n                    // and this browser supports shadow dom\n                    // add the read-only property \"shadowRoot\" to the host element\n                    // adding the shadow root build conditionals to minimize runtime\n                    if (supportsShadowDom) {\n                        {\n                            self.attachShadow({ mode: 'open' });\n                        }\n                    }\n                    else if ( !('shadowRoot' in self)) {\n                        self.shadowRoot = self;\n                    }\n                }\n            }\n            connectedCallback() {\n                if (appLoadFallback) {\n                    clearTimeout(appLoadFallback);\n                    appLoadFallback = null;\n                }\n                if (isBootstrapping) {\n                    // connectedCallback will be processed once all components have been registered\n                    deferredConnectedCallbacks.push(this);\n                }\n                else {\n                    plt.jmp(() => connectedCallback(this, cmpMeta));\n                }\n            }\n            disconnectedCallback() {\n                plt.jmp(() => disconnectedCallback(this));\n            }\n            forceUpdate() {\n                forceUpdate(this, cmpMeta);\n            }\n            componentOnReady() {\n                return getHostRef(this).$onReadyPromise$;\n            }\n        };\n        cmpMeta.$lazyBundleIds$ = lazyBundle[0];\n        if (!exclude.includes(tagName) && !customElements.get(tagName)) {\n            cmpTags.push(tagName);\n            customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1 /* isElementConstructor */));\n        }\n    }));\n    {\n        visibilityStyle.innerHTML = cmpTags + HYDRATED_CSS;\n        visibilityStyle.setAttribute('data-styles', '');\n        head.insertBefore(visibilityStyle, metaCharset ? metaCharset.nextSibling : head.firstChild);\n    }\n    // Process deferred connectedCallbacks now all components have been registered\n    isBootstrapping = false;\n    if (deferredConnectedCallbacks.length > 0) {\n        deferredConnectedCallbacks.forEach(host => host.connectedCallback());\n    }\n    else {\n        {\n            plt.jmp(() => appLoadFallback = setTimeout(appDidLoad, 30));\n        }\n    }\n    // Fallback appLoad event\n    endBootstrap();\n};\nconst createEvent = (ref, name, flags) => {\n    const elm = getElement(ref);\n    return {\n        emit: (detail) => {\n            const ev = new ( CustomEvent)(name, {\n                bubbles: !!(flags & 4 /* Bubbles */),\n                composed: !!(flags & 2 /* Composed */),\n                cancelable: !!(flags & 1 /* Cancellable */),\n                detail\n            });\n            elm.dispatchEvent(ev);\n            return ev;\n        }\n    };\n};\nconst getAssetPath = (path) => {\n    const assetUrl = new URL(path, plt.$resourcesUrl$);\n    return (assetUrl.origin !== win.location.origin)\n        ? assetUrl.href\n        : assetUrl.pathname;\n};\nconst getContext = (_elm, context) => {\n    if (context in Context) {\n        return Context[context];\n    }\n    else if (context === 'window') {\n        return win;\n    }\n    else if (context === 'document') {\n        return doc;\n    }\n    else if (context === 'isServer' || context === 'isPrerender') {\n        return  false;\n    }\n    else if (context === 'isClient') {\n        return  true;\n    }\n    else if (context === 'resourcesUrl' || context === 'publicPath') {\n        return getAssetPath('.');\n    }\n    else if (context === 'queue') {\n        return {\n            write: writeTask,\n            read: readTask,\n            tick: {\n                then(cb) {\n                    return nextTick(cb);\n                }\n            }\n        };\n    }\n    return undefined;\n};\nconst getElement = (ref) =>  getHostRef(ref).$hostElement$ ;\n\nexport { Host as H, patchEsm as a, bootstrapLazy as b, createEvent as c, getContext as d, getElement as g, h, patchBrowser as p, registerInstance as r };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}