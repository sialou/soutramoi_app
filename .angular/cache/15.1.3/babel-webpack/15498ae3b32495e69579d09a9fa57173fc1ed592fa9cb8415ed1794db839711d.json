{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, NgModule } from '@angular/core';\n\n/**\r\n * A storage service implementation that is used as a proxy for another storage service. This is used to create storage services with a\r\n * different default transcoder.\r\n */\nclass ProxyStorageService {\n  /**\r\n   * Creates a new `ProxyStorageService` instance that uses the specified transcoder by default for read and write operations. Actual\r\n   * read and writes are delegated to given storage service.\r\n   *\r\n   * @param defaultTranscoder Transcoder which is to be used by default for storage read and write operations.\r\n   * @param subject           Storage service which should handle to actual storage of data.\r\n   */\n  constructor(defaultTranscoder, subject) {\n    this.defaultTranscoder = defaultTranscoder;\n    this.subject = subject;\n  }\n  /**\r\n   * Checks whether an entry with the specified key exists in the storage.\r\n   *\r\n   * @param   key Identifier of the entry for which its presence in the storage is to be checked.\r\n   * @returns     `true` if an entry with the specified key exists in the storage, `false` if not.\r\n   */\n  has(key) {\n    return this.subject.has(key);\n  }\n  /*\r\n   * Retrieves the value stored for the entry that is associated with the specified key. The given decoder is used to convert the stored\r\n   * value to the desired type. If no entry for the specified key exists or if the decoder is unable to decode the stored value, then\r\n   * `undefined` will be returned.\r\n   *\r\n   * @param   key     Identifier of the entry whose value is to be retrieved.\r\n   * @param   decoder Decoder to use for converting the stored value to the desired return type.\r\n   * @returns         Value of the entry that is identified by the specified key. In case the entry does not exist or if it cannot be\r\n   *                  loaded (due to a decoding issue), then `undefined` will be returned by this function.\r\n   */\n  get(key, decoder) {\n    return this.subject.get(key, decoder ?? this.defaultTranscoder);\n  }\n  /**\r\n   * Creates or updates the entry identified by the specified key with the given value. The specified encoder is used to convert the given\r\n   * value into a format that can be stored by the storage service's underlying storage.\r\n   *\r\n   * Storing a value into the storage service will ensure that an equivalent of the value can be read back, i.e. the data and structure of\r\n   * the value will be the same. It, however, does not necessarily return the same reference.\r\n   *\r\n   * @param key     Identifier of the entry which is to be created or updated.\r\n   * @param value   Value which is to be stored.\r\n   * @param encoder Encoder used to convert the given value into a format that can be used for storage.\r\n   */\n  set(key, value, encoder) {\n    this.subject.set(key, value, encoder ?? this.defaultTranscoder);\n  }\n  /**\r\n   * Removes the entry that is identified by the specified key. Attempting to remove an entry for an unknown key will have no effect.\r\n   * Attempting to retrieve an entry via the `get` method after it has been removed will result in `undefined`.\r\n   *\r\n   * @param key Identifier of the entry which is to be removed.\r\n   */\n  remove(key) {\n    this.subject.remove(key);\n  }\n  /**\r\n   * Clears the storage by removing all entries. Subsequent `get(x)` calls for a key *x* will return `undefined`, until a new value is set\r\n   * for key *x*.\r\n   */\n  clear() {\n    this.subject.clear();\n  }\n  /**\r\n   * Creates a new storage service that uses the specified transcoder by default for read and write operations. The new storage service\r\n   * uses the storage service on which this function is invoked as underlying storage. Both storage services will thus be able to access\r\n   * the same data.\r\n   *\r\n   * The default transcoder will not be changed for the storage service on which this function is invoked.\r\n   *\r\n   * @param   transcoder Transcoder that should be used by default for read and write operations by the new storage service.\r\n   * @returns            A new storage service that uses the specified transcoder by default.\r\n   */\n  withDefaultTranscoder(transcoder) {\n    return new ProxyStorageService(transcoder, this.subject);\n  }\n}\n\n/**\r\n * Base implementation for storage services.\r\n */\nclass BaseStorageService {\n  /**\r\n   * Creates a new `BaseStorageService` that uses the specified transcoder by default for read and write operations.\r\n   *\r\n   * @param defaultTranscoder Transcoder which is to be used by default for storage read and write operations.\r\n   */\n  constructor(defaultTranscoder) {\n    this.defaultTranscoder = defaultTranscoder;\n  }\n  /**\r\n   * Retrieves the value stored for the entry that is associated with the specified key. The given decoder is used to convert the stored\r\n   * value to the desired type. If no entry for the specified key exists or if the decoder is unable to decode the stored value, then\r\n   * `undefined` will be returned.\r\n   *\r\n   * @param   key     Identifier of the entry whose value is to be retrieved.\r\n   * @param   decoder Decoder to use for converting the stored value to the desired return type.\r\n   * @returns         Value of the entry that is identified by the specified key. In case the entry does not exist or if it cannot be\r\n   *                  loaded (due to a decoding issue), then `undefined` will be returned by this function.\r\n   */\n  get(key, decoder) {\n    const value = this.getItem(key);\n    return value !== undefined ? (decoder ?? this.defaultTranscoder).decode(value) : undefined;\n  }\n  /**\r\n   * Creates or updates the entry identified by the specified key with the given value. The specified encoder is used to convert the given\r\n   * value into a format that can be stored by the storage service's underlying storage.\r\n   *\r\n   * Storing a value into the storage service will ensure that an equivalent of the value can be read back, i.e. the data and structure of\r\n   * the value will be the same. It, however, does not necessarily return the same reference.\r\n   *\r\n   * @param key     Identifier of the entry which is to be created or updated.\r\n   * @param value   Value which is to be stored.\r\n   * @param encoder Encoder used to convert the given value into a format that can be used for storage.\r\n   */\n  set(key, value, encoder) {\n    this.setItem(key, (encoder ?? this.defaultTranscoder).encode(value));\n  }\n  /**\r\n   * Creates a new storage service that uses the specified transcoder by default for read and write operations. The new storage service\r\n   * uses the storage service on which this function is invoked as underlying storage. Both storage services will thus be able to access\r\n   * the same data.\r\n   *\r\n   * The default transcoder will not be changed for the storage service on which this function is invoked.\r\n   *\r\n   * @param   transcoder Transcoder that should be used by default for read and write operations by the new storage service.\r\n   * @returns            A new storage service that uses the specified transcoder by default.\r\n   */\n  withDefaultTranscoder(transcoder) {\n    return new ProxyStorageService(transcoder, this);\n  }\n}\n\n/** Transcoder that encodes values as JSON strings. */\nclass JsonStorageTranscoder {\n  encode(value) {\n    return JSON.stringify(value);\n  }\n  decode(value) {\n    try {\n      return JSON.parse(value);\n    } catch (error) {\n      return undefined;\n    }\n  }\n}\n/** Transcoder that encodes/decodes strings **as is**, i.e. values are not modified in any way. */\nclass StringStorageTranscoder {\n  encode(value) {\n    return value;\n  }\n  decode(value) {\n    return value;\n  }\n}\n/** Transcoder that encodes/decodes `boolean` values. */\nclass BooleanStorageTranscoder {\n  encode(value) {\n    return value.toString();\n  }\n  decode(value) {\n    if (value === 'true') {\n      return true;\n    }\n    if (value === 'false') {\n      return false;\n    }\n    return undefined;\n  }\n}\n/** Transcoder that encodes/decodes `number` values. */\nclass NumberStorageTranscoder {\n  encode(value) {\n    return value.toString();\n  }\n  decode(value) {\n    const parsedNumber = Number(value);\n    return Number.isFinite(parsedNumber) ? parsedNumber : undefined;\n  }\n}\n/** Transcoder that encodes/decodes `Date` values to ISO strings. */\nclass DateIsoStorageTranscoder {\n  encode(value) {\n    return value.toISOString();\n  }\n  decode(value) {\n    const timestamp = Date.parse(value);\n    return isNaN(timestamp) ? undefined : new Date(timestamp);\n  }\n}\n/** Transcoder that encodes/decodes `Date` values to epoch timestamps. */\nclass DateEpochStorageTranscoder {\n  encode(value) {\n    return value.valueOf().toString();\n  }\n  decode(value) {\n    const timestamp = parseInt(value, 10);\n    return isNaN(timestamp) ? undefined : new Date(timestamp);\n  }\n}\n/** A set of storage transcoders. */\nconst StorageTranscoders = {\n  /** Transcoder that encodes values as JSON strings. */\n  JSON: new JsonStorageTranscoder(),\n  /** Transcoder that encodes/decodes strings **as is**, i.e. values are not modified in any way. */\n  STRING: new StringStorageTranscoder(),\n  /** Transcoder that encodes/decodes `boolean` values. */\n  BOOLEAN: new BooleanStorageTranscoder(),\n  /** Transcoder that encodes/decodes `number` values. */\n  NUMBER: new NumberStorageTranscoder(),\n  /** Transcoder that encodes/decodes `Date` values into ISO strings. */\n  DATE_ISO_STRING: new DateIsoStorageTranscoder(),\n  /** Transcoder that encodes/decodes `Date` values into epoch timestamps. */\n  DATE_EPOCH_TIME: new DateEpochStorageTranscoder()\n};\n\n/**\r\n * A volatile `StorageService` implementation. This service guarantees that data stored will remain available as long as the application\r\n * instance is active. After the application is terminated all data will be lost.\r\n */\nclass InMemoryStorageService extends BaseStorageService {\n  /**\r\n   * Creates a new `InMemoryStorageService` instance.\r\n   */\n  constructor() {\n    super(StorageTranscoders.JSON);\n    /** A map that serves as the underlying backing storage for this service. */\n    this.storage = new Map();\n  }\n  /**\r\n   * Checks whether an entry with the specified key exists in the storage.\r\n   *\r\n   * @param   key Identifier of the entry for which its presence in the storage is to be checked.\r\n   * @returns     `true` if an entry with the specified key exists in the storage, `false` if not.\r\n   */\n  has(key) {\n    return this.storage.has(key);\n  }\n  /**\r\n   * Removes the entry that is identified by the specified key. Attempting to remove an entry for an unknown key will have no effect.\r\n   * Attempting to retrieve an entry via the `get` method after it has been removed will result in `undefined`.\r\n   *\r\n   * @param key Identifier of the entry which is to be removed.\r\n   */\n  remove(key) {\n    this.storage.delete(key);\n  }\n  /**\r\n   * Clears the storage by removing all entries. Subsequent `get(x)` calls for a key *x* will return `undefined`, until a new value is set\r\n   * for key *x*.\r\n   */\n  clear() {\n    this.storage.clear();\n  }\n  /**\r\n   * Performs the actual retrieval of a value from storage.\r\n   *\r\n   * @param   key Identifier of the entry whose value is to be retrieved.\r\n   * @returns     The value that is stored for the specified entry or `undefined` if no entry exists for the specified key.\r\n   */\n  getItem(key) {\n    if (!this.storage.has(key)) {\n      return undefined;\n    }\n    return this.storage.get(key);\n  }\n  /**\r\n   * Stores the provided value using specified key in the storage.\r\n   *\r\n   * @param key   Identifier of the entry for which the value is to be stored.\r\n   * @param value The value that is to be stored.\r\n   */\n  setItem(key, value) {\n    this.storage.set(key, value);\n  }\n}\n\n/**\r\n * An implementation of `StorageService` interface that uses an underlying (web) `Storage` object, such as `localStorage` and\r\n * `sessionStorage`, as backing data store. This class basically wraps the `Storage` object so it can be accessed through the\r\n * `StorageService` interface.\r\n */\nclass WebStorageService extends BaseStorageService {\n  /**\r\n   * Creates a new `WebStorageService` instance that uses the specified (web) storage object as underlying backing storage.\r\n   *\r\n   * @param storage Storage object which is to be wrapped in a class that implements the `StorageService` interface.\r\n   */\n  constructor(storage) {\n    super(StorageTranscoders.JSON);\n    this.storage = storage;\n  }\n  /**\r\n   * Checks whether an entry with the specified key exists in the storage.\r\n   *\r\n   * @param   key Identifier of the entry for which its presence in the storage is to be checked.\r\n   * @returns     `true` if an entry with the specified key exists in the storage, `false` if not.\r\n   */\n  has(key) {\n    return this.storage.getItem(key) !== null;\n  }\n  /**\r\n   * Removes the entry that is identified by the specified key. Attempting to remove an entry for an unknown key will have no effect.\r\n   * Attempting to retrieve an entry via the `get` method after it has been removed will result in `undefined`.\r\n   *\r\n   * @param key Identifier of the entry which is to be removed.\r\n   */\n  remove(key) {\n    this.storage.removeItem(key);\n  }\n  /**\r\n   * Clears the storage by removing all entries. Subsequent `get(x)` calls for a key *x* will return `undefined`, until a new value is set\r\n   * for key *x*.\r\n   */\n  clear() {\n    this.storage.clear();\n  }\n  /**\r\n   * Performs the actual retrieval of a value from storage.\r\n   *\r\n   * @param   key Identifier of the entry whose value is to be retrieved.\r\n   * @returns     The value that is stored for the specified entry or `undefined` if no entry exists for the specified key.\r\n   */\n  getItem(key) {\n    const value = this.storage.getItem(key);\n    return value !== null ? value : undefined;\n  }\n  /**\r\n   * Stores the provided value using specified key in the storage.\r\n   *\r\n   * @param key   Identifier of the entry for which the value is to be stored.\r\n   * @param value The value that is to be stored.\r\n   */\n  setItem(key, value) {\n    return this.storage.setItem(key, value);\n  }\n}\n/**\r\n * Checks whether the specified (web) storage is available and functional. This might not be the case for older browsers. However even\r\n * certain browsers that do support the web storage API can, under some circumstances, have non functional storage objects. For example,\r\n * Safari is known to have `localStorage` and `sessionStorage` throw exceptions in private mode.\r\n *\r\n * @param   storage Storage object which is to be tested for availability.\r\n * @returns         `true` if the specified storage can be used, `false` if not.\r\n */\nfunction isStorageAvailable(storage) {\n  // Check if storage is available.\n  if (!storage) {\n    return false;\n  }\n  // Check if the storage can actually be accessed.\n  try {\n    const now = Date.now();\n    const testItemKey = `storage-test-entry-${now}`;\n    const testItemValue = `storage-test-value-${now}`;\n    storage.setItem(testItemKey, testItemValue);\n    const retrievedItemValue = storage.getItem(testItemKey);\n    storage.removeItem(testItemKey);\n    return retrievedItemValue === testItemValue;\n  } catch (error) {\n    return false;\n  }\n}\n/**\r\n * Checks whether session storage is available and functional. This might not be the case for older browsers. However even certain browsers\r\n * that do support the web storage API can, under some circumstances, have non functional storage objects. For example, Safari is known to\r\n * have `sessionStorage` throw exceptions in private mode.\r\n *\r\n * @returns `true` if session storage can be used, `false` if not.\r\n */\nfunction isSessionStorageAvailable() {\n  try {\n    if (typeof sessionStorage !== 'undefined') {\n      return isStorageAvailable(sessionStorage);\n    }\n  } catch {}\n  return false;\n}\n/**\r\n * Checks whether local storage is available and functional. This might not be the case for older browsers. However even certain browsers\r\n * that do support the web storage API can, under some circumstances, have non functional storage objects. For example, Safari is known to\r\n * have `localStorage` throw exceptions in private mode.\r\n *\r\n * @returns `true` if local storage can be used, `false` if not.\r\n */\nfunction isLocalStorageAvailable() {\n  try {\n    if (typeof localStorage !== 'undefined') {\n      return isStorageAvailable(localStorage);\n    }\n  } catch {}\n  return false;\n}\nfunction sessionStorageFactory() {\n  if (isSessionStorageAvailable()) {\n    return new WebStorageService(sessionStorage);\n  }\n  return new InMemoryStorageService();\n}\n/** Injection token for the session storage service. */\nconst SESSION_STORAGE = new InjectionToken('SESSION_STORAGE', {\n  providedIn: 'root',\n  factory: sessionStorageFactory\n});\nfunction localStorageFactory() {\n  if (isLocalStorageAvailable()) {\n    return new WebStorageService(localStorage);\n  }\n  return new InMemoryStorageService();\n}\n/** Injection token for the local storage service. */\nconst LOCAL_STORAGE = new InjectionToken('LOCAL_STORAGE', {\n  providedIn: 'root',\n  factory: localStorageFactory\n});\n\n/**\r\n * @deprecated You no longer need to import the `StorageServiceModule`, since the `SESSION_STORAGE` and `LOCAL_STORAGE` injection tokens are\r\n * now 'self providing' in the root injector.\r\n */\nclass StorageServiceModule {}\nStorageServiceModule.ɵfac = function StorageServiceModule_Factory(t) {\n  return new (t || StorageServiceModule)();\n};\nStorageServiceModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: StorageServiceModule\n});\nStorageServiceModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StorageServiceModule, [{\n    type: NgModule\n  }], null, null);\n})();\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { BaseStorageService, BooleanStorageTranscoder, DateEpochStorageTranscoder, DateIsoStorageTranscoder, InMemoryStorageService, JsonStorageTranscoder, LOCAL_STORAGE, NumberStorageTranscoder, ProxyStorageService, SESSION_STORAGE, StorageServiceModule, StorageTranscoders, StringStorageTranscoder, WebStorageService, isLocalStorageAvailable, isSessionStorageAvailable, isStorageAvailable, localStorageFactory, sessionStorageFactory };","map":{"version":3,"names":["i0","InjectionToken","NgModule","ProxyStorageService","constructor","defaultTranscoder","subject","has","key","get","decoder","set","value","encoder","remove","clear","withDefaultTranscoder","transcoder","BaseStorageService","getItem","undefined","decode","setItem","encode","JsonStorageTranscoder","JSON","stringify","parse","error","StringStorageTranscoder","BooleanStorageTranscoder","toString","NumberStorageTranscoder","parsedNumber","Number","isFinite","DateIsoStorageTranscoder","toISOString","timestamp","Date","isNaN","DateEpochStorageTranscoder","valueOf","parseInt","StorageTranscoders","STRING","BOOLEAN","NUMBER","DATE_ISO_STRING","DATE_EPOCH_TIME","InMemoryStorageService","storage","Map","delete","WebStorageService","removeItem","isStorageAvailable","now","testItemKey","testItemValue","retrievedItemValue","isSessionStorageAvailable","sessionStorage","isLocalStorageAvailable","localStorage","sessionStorageFactory","SESSION_STORAGE","providedIn","factory","localStorageFactory","LOCAL_STORAGE","StorageServiceModule","ɵfac","ɵmod","ɵinj","type"],"sources":["/home/digifemmes-22lab149/Bureau/soutramoi_app/node_modules/ngx-webstorage-service/fesm2020/ngx-webstorage-service.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, NgModule } from '@angular/core';\n\n/**\r\n * A storage service implementation that is used as a proxy for another storage service. This is used to create storage services with a\r\n * different default transcoder.\r\n */\r\nclass ProxyStorageService {\r\n    /**\r\n     * Creates a new `ProxyStorageService` instance that uses the specified transcoder by default for read and write operations. Actual\r\n     * read and writes are delegated to given storage service.\r\n     *\r\n     * @param defaultTranscoder Transcoder which is to be used by default for storage read and write operations.\r\n     * @param subject           Storage service which should handle to actual storage of data.\r\n     */\r\n    constructor(defaultTranscoder, subject) {\r\n        this.defaultTranscoder = defaultTranscoder;\r\n        this.subject = subject;\r\n    }\r\n    /**\r\n     * Checks whether an entry with the specified key exists in the storage.\r\n     *\r\n     * @param   key Identifier of the entry for which its presence in the storage is to be checked.\r\n     * @returns     `true` if an entry with the specified key exists in the storage, `false` if not.\r\n     */\r\n    has(key) {\r\n        return this.subject.has(key);\r\n    }\r\n    /*\r\n     * Retrieves the value stored for the entry that is associated with the specified key. The given decoder is used to convert the stored\r\n     * value to the desired type. If no entry for the specified key exists or if the decoder is unable to decode the stored value, then\r\n     * `undefined` will be returned.\r\n     *\r\n     * @param   key     Identifier of the entry whose value is to be retrieved.\r\n     * @param   decoder Decoder to use for converting the stored value to the desired return type.\r\n     * @returns         Value of the entry that is identified by the specified key. In case the entry does not exist or if it cannot be\r\n     *                  loaded (due to a decoding issue), then `undefined` will be returned by this function.\r\n     */\r\n    get(key, decoder) {\r\n        return this.subject.get(key, decoder ?? this.defaultTranscoder);\r\n    }\r\n    /**\r\n     * Creates or updates the entry identified by the specified key with the given value. The specified encoder is used to convert the given\r\n     * value into a format that can be stored by the storage service's underlying storage.\r\n     *\r\n     * Storing a value into the storage service will ensure that an equivalent of the value can be read back, i.e. the data and structure of\r\n     * the value will be the same. It, however, does not necessarily return the same reference.\r\n     *\r\n     * @param key     Identifier of the entry which is to be created or updated.\r\n     * @param value   Value which is to be stored.\r\n     * @param encoder Encoder used to convert the given value into a format that can be used for storage.\r\n     */\r\n    set(key, value, encoder) {\r\n        this.subject.set(key, value, encoder ?? this.defaultTranscoder);\r\n    }\r\n    /**\r\n     * Removes the entry that is identified by the specified key. Attempting to remove an entry for an unknown key will have no effect.\r\n     * Attempting to retrieve an entry via the `get` method after it has been removed will result in `undefined`.\r\n     *\r\n     * @param key Identifier of the entry which is to be removed.\r\n     */\r\n    remove(key) {\r\n        this.subject.remove(key);\r\n    }\r\n    /**\r\n     * Clears the storage by removing all entries. Subsequent `get(x)` calls for a key *x* will return `undefined`, until a new value is set\r\n     * for key *x*.\r\n     */\r\n    clear() {\r\n        this.subject.clear();\r\n    }\r\n    /**\r\n     * Creates a new storage service that uses the specified transcoder by default for read and write operations. The new storage service\r\n     * uses the storage service on which this function is invoked as underlying storage. Both storage services will thus be able to access\r\n     * the same data.\r\n     *\r\n     * The default transcoder will not be changed for the storage service on which this function is invoked.\r\n     *\r\n     * @param   transcoder Transcoder that should be used by default for read and write operations by the new storage service.\r\n     * @returns            A new storage service that uses the specified transcoder by default.\r\n     */\r\n    withDefaultTranscoder(transcoder) {\r\n        return new ProxyStorageService(transcoder, this.subject);\r\n    }\r\n}\n\n/**\r\n * Base implementation for storage services.\r\n */\r\nclass BaseStorageService {\r\n    /**\r\n     * Creates a new `BaseStorageService` that uses the specified transcoder by default for read and write operations.\r\n     *\r\n     * @param defaultTranscoder Transcoder which is to be used by default for storage read and write operations.\r\n     */\r\n    constructor(defaultTranscoder) {\r\n        this.defaultTranscoder = defaultTranscoder;\r\n    }\r\n    /**\r\n     * Retrieves the value stored for the entry that is associated with the specified key. The given decoder is used to convert the stored\r\n     * value to the desired type. If no entry for the specified key exists or if the decoder is unable to decode the stored value, then\r\n     * `undefined` will be returned.\r\n     *\r\n     * @param   key     Identifier of the entry whose value is to be retrieved.\r\n     * @param   decoder Decoder to use for converting the stored value to the desired return type.\r\n     * @returns         Value of the entry that is identified by the specified key. In case the entry does not exist or if it cannot be\r\n     *                  loaded (due to a decoding issue), then `undefined` will be returned by this function.\r\n     */\r\n    get(key, decoder) {\r\n        const value = this.getItem(key);\r\n        return value !== undefined ? (decoder ?? this.defaultTranscoder).decode(value) : undefined;\r\n    }\r\n    /**\r\n     * Creates or updates the entry identified by the specified key with the given value. The specified encoder is used to convert the given\r\n     * value into a format that can be stored by the storage service's underlying storage.\r\n     *\r\n     * Storing a value into the storage service will ensure that an equivalent of the value can be read back, i.e. the data and structure of\r\n     * the value will be the same. It, however, does not necessarily return the same reference.\r\n     *\r\n     * @param key     Identifier of the entry which is to be created or updated.\r\n     * @param value   Value which is to be stored.\r\n     * @param encoder Encoder used to convert the given value into a format that can be used for storage.\r\n     */\r\n    set(key, value, encoder) {\r\n        this.setItem(key, (encoder ?? this.defaultTranscoder).encode(value));\r\n    }\r\n    /**\r\n     * Creates a new storage service that uses the specified transcoder by default for read and write operations. The new storage service\r\n     * uses the storage service on which this function is invoked as underlying storage. Both storage services will thus be able to access\r\n     * the same data.\r\n     *\r\n     * The default transcoder will not be changed for the storage service on which this function is invoked.\r\n     *\r\n     * @param   transcoder Transcoder that should be used by default for read and write operations by the new storage service.\r\n     * @returns            A new storage service that uses the specified transcoder by default.\r\n     */\r\n    withDefaultTranscoder(transcoder) {\r\n        return new ProxyStorageService(transcoder, this);\r\n    }\r\n}\n\n/** Transcoder that encodes values as JSON strings. */\r\nclass JsonStorageTranscoder {\r\n    encode(value) {\r\n        return JSON.stringify(value);\r\n    }\r\n    decode(value) {\r\n        try {\r\n            return JSON.parse(value);\r\n        }\r\n        catch (error) {\r\n            return undefined;\r\n        }\r\n    }\r\n}\r\n/** Transcoder that encodes/decodes strings **as is**, i.e. values are not modified in any way. */\r\nclass StringStorageTranscoder {\r\n    encode(value) {\r\n        return value;\r\n    }\r\n    decode(value) {\r\n        return value;\r\n    }\r\n}\r\n/** Transcoder that encodes/decodes `boolean` values. */\r\nclass BooleanStorageTranscoder {\r\n    encode(value) {\r\n        return value.toString();\r\n    }\r\n    decode(value) {\r\n        if (value === 'true') {\r\n            return true;\r\n        }\r\n        if (value === 'false') {\r\n            return false;\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\n/** Transcoder that encodes/decodes `number` values. */\r\nclass NumberStorageTranscoder {\r\n    encode(value) {\r\n        return value.toString();\r\n    }\r\n    decode(value) {\r\n        const parsedNumber = Number(value);\r\n        return Number.isFinite(parsedNumber) ? parsedNumber : undefined;\r\n    }\r\n}\r\n/** Transcoder that encodes/decodes `Date` values to ISO strings. */\r\nclass DateIsoStorageTranscoder {\r\n    encode(value) {\r\n        return value.toISOString();\r\n    }\r\n    decode(value) {\r\n        const timestamp = Date.parse(value);\r\n        return isNaN(timestamp) ? undefined : new Date(timestamp);\r\n    }\r\n}\r\n/** Transcoder that encodes/decodes `Date` values to epoch timestamps. */\r\nclass DateEpochStorageTranscoder {\r\n    encode(value) {\r\n        return value.valueOf().toString();\r\n    }\r\n    decode(value) {\r\n        const timestamp = parseInt(value, 10);\r\n        return isNaN(timestamp) ? undefined : new Date(timestamp);\r\n    }\r\n}\r\n/** A set of storage transcoders. */\r\nconst StorageTranscoders = {\r\n    /** Transcoder that encodes values as JSON strings. */\r\n    JSON: new JsonStorageTranscoder(),\r\n    /** Transcoder that encodes/decodes strings **as is**, i.e. values are not modified in any way. */\r\n    STRING: new StringStorageTranscoder(),\r\n    /** Transcoder that encodes/decodes `boolean` values. */\r\n    BOOLEAN: new BooleanStorageTranscoder(),\r\n    /** Transcoder that encodes/decodes `number` values. */\r\n    NUMBER: new NumberStorageTranscoder(),\r\n    /** Transcoder that encodes/decodes `Date` values into ISO strings. */\r\n    DATE_ISO_STRING: new DateIsoStorageTranscoder(),\r\n    /** Transcoder that encodes/decodes `Date` values into epoch timestamps. */\r\n    DATE_EPOCH_TIME: new DateEpochStorageTranscoder(),\r\n};\n\n/**\r\n * A volatile `StorageService` implementation. This service guarantees that data stored will remain available as long as the application\r\n * instance is active. After the application is terminated all data will be lost.\r\n */\r\nclass InMemoryStorageService extends BaseStorageService {\r\n    /**\r\n     * Creates a new `InMemoryStorageService` instance.\r\n     */\r\n    constructor() {\r\n        super(StorageTranscoders.JSON);\r\n        /** A map that serves as the underlying backing storage for this service. */\r\n        this.storage = new Map();\r\n    }\r\n    /**\r\n     * Checks whether an entry with the specified key exists in the storage.\r\n     *\r\n     * @param   key Identifier of the entry for which its presence in the storage is to be checked.\r\n     * @returns     `true` if an entry with the specified key exists in the storage, `false` if not.\r\n     */\r\n    has(key) {\r\n        return this.storage.has(key);\r\n    }\r\n    /**\r\n     * Removes the entry that is identified by the specified key. Attempting to remove an entry for an unknown key will have no effect.\r\n     * Attempting to retrieve an entry via the `get` method after it has been removed will result in `undefined`.\r\n     *\r\n     * @param key Identifier of the entry which is to be removed.\r\n     */\r\n    remove(key) {\r\n        this.storage.delete(key);\r\n    }\r\n    /**\r\n     * Clears the storage by removing all entries. Subsequent `get(x)` calls for a key *x* will return `undefined`, until a new value is set\r\n     * for key *x*.\r\n     */\r\n    clear() {\r\n        this.storage.clear();\r\n    }\r\n    /**\r\n     * Performs the actual retrieval of a value from storage.\r\n     *\r\n     * @param   key Identifier of the entry whose value is to be retrieved.\r\n     * @returns     The value that is stored for the specified entry or `undefined` if no entry exists for the specified key.\r\n     */\r\n    getItem(key) {\r\n        if (!this.storage.has(key)) {\r\n            return undefined;\r\n        }\r\n        return this.storage.get(key);\r\n    }\r\n    /**\r\n     * Stores the provided value using specified key in the storage.\r\n     *\r\n     * @param key   Identifier of the entry for which the value is to be stored.\r\n     * @param value The value that is to be stored.\r\n     */\r\n    setItem(key, value) {\r\n        this.storage.set(key, value);\r\n    }\r\n}\n\n/**\r\n * An implementation of `StorageService` interface that uses an underlying (web) `Storage` object, such as `localStorage` and\r\n * `sessionStorage`, as backing data store. This class basically wraps the `Storage` object so it can be accessed through the\r\n * `StorageService` interface.\r\n */\r\nclass WebStorageService extends BaseStorageService {\r\n    /**\r\n     * Creates a new `WebStorageService` instance that uses the specified (web) storage object as underlying backing storage.\r\n     *\r\n     * @param storage Storage object which is to be wrapped in a class that implements the `StorageService` interface.\r\n     */\r\n    constructor(storage) {\r\n        super(StorageTranscoders.JSON);\r\n        this.storage = storage;\r\n    }\r\n    /**\r\n     * Checks whether an entry with the specified key exists in the storage.\r\n     *\r\n     * @param   key Identifier of the entry for which its presence in the storage is to be checked.\r\n     * @returns     `true` if an entry with the specified key exists in the storage, `false` if not.\r\n     */\r\n    has(key) {\r\n        return this.storage.getItem(key) !== null;\r\n    }\r\n    /**\r\n     * Removes the entry that is identified by the specified key. Attempting to remove an entry for an unknown key will have no effect.\r\n     * Attempting to retrieve an entry via the `get` method after it has been removed will result in `undefined`.\r\n     *\r\n     * @param key Identifier of the entry which is to be removed.\r\n     */\r\n    remove(key) {\r\n        this.storage.removeItem(key);\r\n    }\r\n    /**\r\n     * Clears the storage by removing all entries. Subsequent `get(x)` calls for a key *x* will return `undefined`, until a new value is set\r\n     * for key *x*.\r\n     */\r\n    clear() {\r\n        this.storage.clear();\r\n    }\r\n    /**\r\n     * Performs the actual retrieval of a value from storage.\r\n     *\r\n     * @param   key Identifier of the entry whose value is to be retrieved.\r\n     * @returns     The value that is stored for the specified entry or `undefined` if no entry exists for the specified key.\r\n     */\r\n    getItem(key) {\r\n        const value = this.storage.getItem(key);\r\n        return value !== null ? value : undefined;\r\n    }\r\n    /**\r\n     * Stores the provided value using specified key in the storage.\r\n     *\r\n     * @param key   Identifier of the entry for which the value is to be stored.\r\n     * @param value The value that is to be stored.\r\n     */\r\n    setItem(key, value) {\r\n        return this.storage.setItem(key, value);\r\n    }\r\n}\r\n/**\r\n * Checks whether the specified (web) storage is available and functional. This might not be the case for older browsers. However even\r\n * certain browsers that do support the web storage API can, under some circumstances, have non functional storage objects. For example,\r\n * Safari is known to have `localStorage` and `sessionStorage` throw exceptions in private mode.\r\n *\r\n * @param   storage Storage object which is to be tested for availability.\r\n * @returns         `true` if the specified storage can be used, `false` if not.\r\n */\r\nfunction isStorageAvailable(storage) {\r\n    // Check if storage is available.\r\n    if (!storage) {\r\n        return false;\r\n    }\r\n    // Check if the storage can actually be accessed.\r\n    try {\r\n        const now = Date.now();\r\n        const testItemKey = `storage-test-entry-${now}`;\r\n        const testItemValue = `storage-test-value-${now}`;\r\n        storage.setItem(testItemKey, testItemValue);\r\n        const retrievedItemValue = storage.getItem(testItemKey);\r\n        storage.removeItem(testItemKey);\r\n        return retrievedItemValue === testItemValue;\r\n    }\r\n    catch (error) {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * Checks whether session storage is available and functional. This might not be the case for older browsers. However even certain browsers\r\n * that do support the web storage API can, under some circumstances, have non functional storage objects. For example, Safari is known to\r\n * have `sessionStorage` throw exceptions in private mode.\r\n *\r\n * @returns `true` if session storage can be used, `false` if not.\r\n */\r\nfunction isSessionStorageAvailable() {\r\n    try {\r\n        if (typeof sessionStorage !== 'undefined') {\r\n            return isStorageAvailable(sessionStorage);\r\n        }\r\n    }\r\n    catch { }\r\n    return false;\r\n}\r\n/**\r\n * Checks whether local storage is available and functional. This might not be the case for older browsers. However even certain browsers\r\n * that do support the web storage API can, under some circumstances, have non functional storage objects. For example, Safari is known to\r\n * have `localStorage` throw exceptions in private mode.\r\n *\r\n * @returns `true` if local storage can be used, `false` if not.\r\n */\r\nfunction isLocalStorageAvailable() {\r\n    try {\r\n        if (typeof localStorage !== 'undefined') {\r\n            return isStorageAvailable(localStorage);\r\n        }\r\n    }\r\n    catch { }\r\n    return false;\r\n}\n\nfunction sessionStorageFactory() {\r\n    if (isSessionStorageAvailable()) {\r\n        return new WebStorageService(sessionStorage);\r\n    }\r\n    return new InMemoryStorageService();\r\n}\r\n/** Injection token for the session storage service. */\r\nconst SESSION_STORAGE = new InjectionToken('SESSION_STORAGE', { providedIn: 'root', factory: sessionStorageFactory });\r\nfunction localStorageFactory() {\r\n    if (isLocalStorageAvailable()) {\r\n        return new WebStorageService(localStorage);\r\n    }\r\n    return new InMemoryStorageService();\r\n}\r\n/** Injection token for the local storage service. */\r\nconst LOCAL_STORAGE = new InjectionToken('LOCAL_STORAGE', { providedIn: 'root', factory: localStorageFactory });\n\n/**\r\n * @deprecated You no longer need to import the `StorageServiceModule`, since the `SESSION_STORAGE` and `LOCAL_STORAGE` injection tokens are\r\n * now 'self providing' in the root injector.\r\n */\r\nclass StorageServiceModule {\r\n}\r\nStorageServiceModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: StorageServiceModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\nStorageServiceModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: StorageServiceModule });\r\nStorageServiceModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: StorageServiceModule });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: StorageServiceModule, decorators: [{\r\n            type: NgModule\r\n        }] });\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { BaseStorageService, BooleanStorageTranscoder, DateEpochStorageTranscoder, DateIsoStorageTranscoder, InMemoryStorageService, JsonStorageTranscoder, LOCAL_STORAGE, NumberStorageTranscoder, ProxyStorageService, SESSION_STORAGE, StorageServiceModule, StorageTranscoders, StringStorageTranscoder, WebStorageService, isLocalStorageAvailable, isSessionStorageAvailable, isStorageAvailable, localStorageFactory, sessionStorageFactory };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}